


const crypto = require('crypto');

const R_INVALID_IRIREF = /([\x00-\x20<>"{}|^`\\]|%(?![0-9A-F][0-9A-F]))/g;
const F_REPLACE_INVALID_IRIREF = (s_, s_v) => {
	let s_code = s_v.codePointAt(0).toString(16)+'';
	return s_code.length > 4
		? '\\U'+s_code.padStart(8, '0')
		: '\\u'+s_code.padStart(4, '0');
};

const clean_iri = p_iri_dirty => p_iri_dirty.replace(R_INVALID_IRIREF, F_REPLACE_INVALID_IRIREF);



// eslint-disable-next-line no-misleading-character-class
const RT_AVOID_PNAME_NS = /^(?:[\u0000-@[-`{-\u00bf\u00d7\u00f7\u0300-\u306f\u037e\u2000-\u200b\u200e-\u206f\u2190-\u2bff\u2ff0-\u3000\ud800-\uf8ff\ufdd0-\ufddf\ufffe\uffff].+|(?:.+?[\u0000-,\/:-@[-^`{-\u00b6\u00b8-\u00bf\u00d7\u00f7\u037e\u2000-\u200b\u200e-\u203e\u2041-\u206f\u2190-\u2bff\u2ff0-\u3000\ud800-\uf8ff\ufdd0-\ufddf\ufffe\uffff].*)|.+\.)$/;

// eslint-disable-next-line no-misleading-character-class
const RT_AVOID_PNAME_LOCAL = /^(?:\\|[\u0000-\/;-@[-^`{-\u00bf\u00d7\u00f7\u0300-\u306f\u037e\u2000-\u200b\u200e-\u206f\u2190-\u2bff\u2ff0-\u3000\ud800-\uf8ff\ufdd0-\ufddf\ufffe\uffff].+|(?:.+?(?:\\|[\u0000-,\/;-@[-^`{-\u00b6\u00b8-\u00bf\u00d7\u00f7\u037e\u2000-\u200b\u200e-\u203e\u2041-\u206f\u2190-\u2bff\u2ff0-\u3000\ud800-\uf8ff\ufdd0-\ufddf\ufffe\uffff]).+)|(?:.+?(?:\\|[\u0000-,.\/;-@[-^`{-\u00b6\u00b8-\u00bf\u00d7\u00f7\u037e\u2000-\u200b\u200e-\u203e\u2041-\u206f\u2190-\u2bff\u2ff0-\u3000\ud800-\uf8ff\ufdd0-\ufddf\ufffe\uffff])))$/;

const RT_BOOLEAN_TRUE = /^([Tt](rue)?|TRUE)$/;
const RT_BOOLEAN_FALSE = /^([Ff](alse)?|FALSE)$/;

const S_UUID_V4 = 'xxxxxxxx_xxxx_4xxx_yxxx_xxxxxxxxxxxx';
const R_UUID_V4 = /[xy]/g;

const uuid_v4 = () => {
	let dt_now = Date.now();
	if('undefined' !== typeof performance) dt_now += performance.now();
	return S_UUID_V4.replace(R_UUID_V4, (s) => {
		let x_r = (dt_now + (Math.random()*16)) % 16 | 0;
		dt_now = Math.floor(dt_now / 16);
		return ('x' === s? x_r: ((x_r & 0x3) | 0x8)).toString(16);
	});
};


// symbol to access cache on a prefix mapping
const $_PREFIX_CACHE = Symbol('prefix-cache');

// escape characters for compiling regexes
const R_REGEX_ESCAPE = /[$^*()+[\\{}|.?]/g;

// valid locals of prefixed names
const SR_PN_LOCAL = '((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_:0-9]|%[A-Fa-f0-9]{2}|\\\\[_~.\\-!$&\'()*+,;=/?#@%])(?:(?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}.:]|%[A-Fa-f0-9]{2}|\\\\[_~.\\-!$&\'()*+,;=/?#@%])*(?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}:]|%[A-Fa-f0-9]{2}|\\\\[_~.\\-!$&\'()*+,;=/?#@%]))?)$';


// create a cache on a prefix mapping
function cache_prefixes(h_prefixes, b_terse=false) {
	// regex cache string building
	let a_cache = [];

	// inverse mappings
	let h_inverse = {};

	// each prefix/iri pair
	for(let si_prefix in h_prefixes) {
		let p_iri = h_prefixes[si_prefix];

		// prefix would make an invalid namespace; skip
		if(b_terse && RT_AVOID_PNAME_NS.test(si_prefix)) continue;

		// save inverse mapping
		h_inverse[p_iri] = si_prefix;

		// push iri
		a_cache.push(p_iri.replace(R_REGEX_ESCAPE, '\\$&'));
	}

	// no prefixes; forgo cache
	if(!a_cache.length) return h_prefixes;

	// save cache object
	h_prefixes[$_PREFIX_CACHE] = {
		_r_iris: new RegExp(`^(${a_cache.join('|')})${SR_PN_LOCAL}`, 'u'),
		_h_inverse: h_inverse,
	};

	// freeze object
	return Object.freeze(h_prefixes);
}



// attempt to turn an iri into a terse prefixed name
const terse = (p_iri, h_prefixes) => {
	// ref cache
	let g_cache = h_prefixes[$_PREFIX_CACHE];

	// cache exists
	if(g_cache) {
		// iri matching
		let m_iri = g_cache._r_iris.exec(p_iri);

		// prefix mapped; compress
		if(m_iri) {
			return g_cache._h_inverse[m_iri[1]]+':'+m_iri[2];
		}
	}
	// cache does not exist
	else {
		// best prefix id
		let si_best_prefix = '';
		let s_best_suffix = '';

		// length of longest matching iri
		let nl_best_prefix_iri = -1;

		// each prefix in hash
		for(let si_prefix in h_prefixes) {
			let p_prefix_iri = h_prefixes[si_prefix];

			// target iri starts with prefix iri and its longer than the current best
			if(0 === p_iri.indexOf(p_prefix_iri) && p_prefix_iri.length > nl_best_prefix_iri
				// namespace is okay to use
				&& !RT_AVOID_PNAME_NS.test(si_prefix)
			) {
				// compute suffix
				let s_suffix = p_iri.slice(p_prefix_iri.length);

				// suffix is okay to use
				if(!RT_AVOID_PNAME_LOCAL.test(s_suffix)) {
					s_best_suffix = s_suffix;

					// save prefix id as best
					si_best_prefix = si_prefix;

					// update best iri length
					nl_best_prefix_iri = p_prefix_iri.length;
				}
			}
		}

		// found a prefix
		if(-1 !== nl_best_prefix_iri) {
			// use terse prefixed name
			return si_best_prefix+':'+s_best_suffix;
		}
	}

	// fallback
	return '<'+p_iri+'>';
};

// attempt to turn an iri into a concise prefixed name
const concise = (p_iri, h_prefixes={}) => {
	// ref cache
	let g_cache = h_prefixes[$_PREFIX_CACHE];

	// cache exists
	if(g_cache) {
		// iri matching
		let m_iri = g_cache._r_iris.exec(p_iri);

		// prefix mapped; compress
		if(m_iri) {
			return g_cache._h_inverse[m_iri[1]]+':'+m_iri[2];
		}
	}
	// cache does not exists
	else {
		// best prefix id
		let s_best_prefix_id = '';

		// length of longest matching iri
		let nl_best_prefix_iri = -1;

		// each prefix in hash
		for(let s_prefix_id in h_prefixes) {
			let p_prefix_iri = h_prefixes[s_prefix_id];

			// target iri starts with prefix iri and its longer than the current best
			if(p_iri.startsWith(p_prefix_iri) && p_prefix_iri.length > nl_best_prefix_iri) {
				// save prefix id as best
				s_best_prefix_id = s_prefix_id;

				// update best iri length
				nl_best_prefix_iri = p_prefix_iri.length;
			}
		}

		// found a prefix
		if(-1 !== nl_best_prefix_iri) {
			return s_best_prefix_id+':'+p_iri.slice(nl_best_prefix_iri);
		}
	}

	// no prefix found; default to full iri
	return '>'+p_iri;
};

const R_C1N_DECONSTRUCT = /^([^:]*):(.*)$/;

function c1_to_nt(sc1_in, h_prefixes={}, b_verbose=false) {
	switch(sc1_in[0]) {
		// absolute iri
		case '>': return '<'+sc1_in.slice(1)+'>';

		// blank node
		case '_': {
			// ephemeral hint
			if(sc1_in.length <= 2 || '#' === sc1_in[2]) {
				return (new EphemeralBlankNode())[b_verbose? 'verbose': 'terse']();
			}
			// labeled
			else {
				return sc1_in;
			}
		}

		// simple literal
		case '"': return JSON.stringify(sc1_in.slice(1));

		// languaged literal
		case '@': {
			let i_contents = sc1_in.indexOf('"');
			return JSON.stringify(sc1_in.slice(i_contents+1))+sc1_in.slice(0, i_contents);
		}

		// datatyped literal
		case '^': {
			let i_contents = sc1_in.indexOf('"');
			return JSON.stringify(sc1_in.slice(i_contents+1))+'^^'+c1_to_nt(sc1_in.slice(1, i_contents), h_prefixes, b_verbose);
		}

		// default graph
		case '*': return '';

		// directive / node explicit
		case '<':
		case '`': return factory.c1(sc1_in).terse(h_prefixes);

		// otherwise
		default: {
			// rdf:type alis
			if('a' === sc1_in) return b_verbose? '<http://www.w3.org/1999/02/22-rdf-syntax-ns#type>': 'a';

			// deconstruct prefixed name
			let [, si_prefix, s_suffix] = R_C1N_DECONSTRUCT.exec(sc1_in);

			// avoid illegal prefixed name parts
			if(b_verbose || RT_AVOID_PNAME_LOCAL.test(s_suffix) || RT_AVOID_PNAME_NS.test(si_prefix)) {
				return '<'+h_prefixes[si_prefix]+s_suffix+'>';
			}

			// good as-is
			return sc1_in;
		}
	}
}


class GenericTerm {
	valueOf() {
		return this.concise();
	}

	toString() {
		return this.concise();
	}

	equals(z_other) {
		return z_other
			? this === z_other
				|| (z_other.termType === this.termType && z_other.value === this.value)
			: false;
	}
} Object.assign(GenericTerm.prototype, {
	isGraphyTerm: true,
});


class NamedNode extends GenericTerm {
	constructor(s_iri) {
		super();
		this.value = s_iri;
	}

	concise(h_prefixes={}) {
		return concise(this.value, h_prefixes);
	}

	terse(h_prefixes={}, b_opt=false) {
		return terse(clean_iri(this.value), h_prefixes, b_opt);
	}

	verbose() {
		return '<'+clean_iri(this.value)+'>';
	}

	isolate() {
		return {
			termType: 'NamedNode',
			value: this.value,
		};
	}
} Object.assign(NamedNode.prototype, {
	termType: 'NamedNode',
	isNamedNode: true,
});

const KT_RDF_TYPE = new NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type');
KT_RDF_TYPE.isRdfTypeAlias = true;  // for serialization

const KT_RDF_LANG_STRING = new NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString');
const G_ISOLATE_RDF_LANG_STRING = KT_RDF_LANG_STRING.isolate();

const KT_RDF_FIRST = new NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#first');
const KT_RDF_REST = new NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#rest');
const KT_RDF_NIL = new NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#nil');

const KT_XSD_DATE = new NamedNode('http://www.w3.org/2001/XMLSchema#date');
const KT_XSD_DATETIME = new NamedNode('http://www.w3.org/2001/XMLSchema#dateTime');
const KT_XSD_STRING = new NamedNode('http://www.w3.org/2001/XMLSchema#string');

class GenericLiteral extends GenericTerm {
	equals(z_other) {
		return z_other
			? this === z_other
				|| ('Literal' === z_other.termType && z_other.value === this.value
					&& this.datatype.equals(z_other.datatype) && z_other.language === this.language)
			: false;
	}

	verbose() {
		return JSON.stringify(this.value)
			+ (this.language
				? '@'+this.language
				: '^^'+this.datatype.verbose());
	}

	concise(h_prefixes) {
		if(this.language) {
			return '@'+this.language+'"'+this.value;
		}
		else {
			return '^'+concise(this.datatype.value, h_prefixes)+'"'+this.value;
		}
	}

	terse(h_prefixes={}) {
		// turn into terse
		let st_datatype = this.datatype.terse(h_prefixes);

		// stringify literal
		return JSON.stringify(this.value)
			+ (this.language
				? '@'+this.language
				: '^^'+st_datatype);
	}

	isolate() {
		return {
			termType: 'Literal',
			value: this.value,
			language: this.language,
			datatype: this.datatype.isolate(),
		};
	}
} Object.assign(GenericLiteral.prototype, {
	datatype: KT_XSD_STRING,
	language: '',
	termType: 'Literal',
	isLiteral: true,
	isSimple: false,
});

class LanguagedLiteral extends GenericLiteral {
	constructor(s_value, s_lang) {
		super();
		this.value = s_value;

		// remove optional '@' character from beginning
		this.language = ('@' === s_lang[0]? s_lang.slice(1): s_lang).toLowerCase();
	}

	verbose() {
		return JSON.stringify(this.value)+'@'+this.language;
	}

	concise() {
		return '@'+this.language+'"'+this.value;
	}

	terse() {
		// stringify literal
		return JSON.stringify(this.value)+'@'+this.language;
	}

	isolate() {
		return {
			termType: 'Literal',
			value: this.value,
			language: this.language,
			datatype: G_ISOLATE_RDF_LANG_STRING,
		};
	}
} Object.assign(LanguagedLiteral.prototype, {
	datatype: KT_RDF_LANG_STRING,
	isLanguaged: true,
});


class DatatypedLiteral extends GenericLiteral {
	verbose() {
		return JSON.stringify(this.value)+'^^'+this.datatype.verbose();
	}

	concise(h_prefixes) {
		return '^'+concise(this.datatype.value, h_prefixes)+'"'+this.value;
	}

	terse(h_prefixes={}) {
		// turn into terse
		let st_datatype = this.datatype.terse(h_prefixes);

		// stringify literal
		return JSON.stringify(this.value)+'^^'+st_datatype;
	}

	isolate() {
		return {
			termType: 'Literal',
			value: this.value,
			language: this.language,
			datatype: this.datatype.isolate(),
		};
	}
} Object.assign(DatatypedLiteral.prototype, {
	isDatatyped: true,
});

class ExplicitlyDatatypedLiteral extends DatatypedLiteral {
	constructor(s_value, kt_datatype) {
		super();
		this.value = s_value;
		this.datatype = kt_datatype;
	}
}

class RawLiteral extends GenericTerm {
	constructor(s_value) {
		super();
		this.value = s_value;
	}

	get isSimple() {
		return !this.language && !this.datatype.equals(KT_XSD_STRING);
	}

	get isLanguaged() {
		return !!this.language;
	}

	get isDatatyped() {
		return KT_XSD_STRING.equals(this.datatype);
	}

	equals(z_other) {
		return z_other
			? this === z_other
				|| ('Literal' === z_other.termType && z_other.value === this.value
					&& this.datatype.equals(z_other.datatype) && z_other.language === this.language)
			: false;
	}

	verbose() {
		return JSON.stringify(this.value)
			+ (this.language
				? '@'+this.language
				: '^^'+this.datatype.verbose());
	}

	concise(h_prefixes) {
		if(this.language) {
			return '@'+this.language+'"'+this.value;
		}
		else {
			return '^'+concise(this.datatype.value, h_prefixes)+'"'+this.value;
		}
	}

	terse(h_prefixes={}) {
		// turn into terse
		let st_datatype = this.datatype.terse(h_prefixes);

		// stringify literal
		return JSON.stringify(this.value)
			+ (this.language
				? '@'+this.language
				: '^^'+st_datatype);
	}

	isolate() {
		return {
			termType: 'Literal',
			value: this.value,
			language: this.language,
			datatype: this.datatype.isolate(),
		};
	}
} Object.assign(RawLiteral.prototype, {
	datatype: KT_XSD_STRING,
	language: '',
	termType: 'Literal',
	isLiteral: true,
});

class SimpleLiteral extends GenericLiteral {
	constructor(s_value) {
		super();
		this.value = s_value;
	}

	verbose() {
		return JSON.stringify(this.value);
	}

	concise() {
		return '"'+this.value;
	}

	terse() {
		return JSON.stringify(this.value);
	}
} Object.assign(SimpleLiteral.prototype, {
	isSimple: true,
});



const KT_XSD_INTEGER = new NamedNode('http://www.w3.org/2001/XMLSchema#integer');
class Literal_Integer extends DatatypedLiteral {
	static from(s_literal) {
		let kt = new Literal_Integer(+s_literal);
		kt.value = s_literal;
		return kt;
	}

	constructor(x_value) {
		super();
		this.value = x_value+'';

		this.number = x_value;
	}

	concise(h_prefixes={}) {
		return '^'+KT_XSD_INTEGER.concise(h_prefixes)+'"'+this.value;
	}

	terse() {
		return this.value.includes('e')
			? `"${this.value}"^^<http://www.w3.org/2001/XMLSchema#integer>`
			: this.value;
	}
} Object.assign(Literal_Integer.prototype, {
	datatype: KT_XSD_INTEGER,

	isNumeric: true,
	isInteger: true,
});
const KT_XSD_DOUBLE = new NamedNode('http://www.w3.org/2001/XMLSchema#double');
class Literal_Double extends DatatypedLiteral {
	static from(s_literal) {
		let kt = new Literal_Double(+s_literal);
		kt.value = s_literal;
		return kt;
	}

	constructor(x_value) {
		super();
		this.value = x_value+'';

		this.number = x_value;
	}

	concise(h_prefixes={}) {
		return '^'+KT_XSD_DOUBLE.concise(h_prefixes)+'"'+this.value;
	}

	terse() {
		return this.number.toExponential();
	}
} Object.assign(Literal_Double.prototype, {
	datatype: KT_XSD_DOUBLE,

	isNumeric: true,
	isDouble: true,
});
const KT_XSD_DECIMAL = new NamedNode('http://www.w3.org/2001/XMLSchema#decimal');
class Literal_Decimal extends DatatypedLiteral {
	static from(s_literal) {
		let kt = new Literal_Decimal(+s_literal);
		kt.value = s_literal;
		return kt;
	}

	constructor(x_value) {
		super();
		this.value = x_value+'';

		this.number = x_value;
	}

	concise(h_prefixes={}) {
		return '^'+KT_XSD_DECIMAL.concise(h_prefixes)+'"'+this.value;
	}

	terse() {
		return this.value.includes('e')
			? `"${this.value}"^^<http://www.w3.org/2001/XMLSchema#decimal>`
			: this.value+(this.value.includes('.')? '': '.0');
	}
} Object.assign(Literal_Decimal.prototype, {
	datatype: KT_XSD_DECIMAL,

	isNumeric: true,
	isDecimal: true,
});
const KT_XSD_BOOLEAN = new NamedNode('http://www.w3.org/2001/XMLSchema#boolean');
class Literal_Boolean extends DatatypedLiteral {
	static from(s_literal) {
		let kt = new Literal_Boolean(+s_literal);
		kt.value = s_literal;
		return kt;
	}

	constructor(b_value) {
		super();
		this.value = b_value+'';
		this.boolean = b_value;
	}

	concise(h_prefixes={}) {
		return '^'+KT_XSD_BOOLEAN.concise(h_prefixes)+'"'+this.value;
	}

	terse() {
		return this.value+'';
	}
} Object.assign(Literal_Boolean.prototype, {
	datatype: KT_XSD_BOOLEAN,
	isBoolean: true,
});



class Literal_PositiveInfinity extends Literal_Double {
	constructor() {
		super(Infinity);
		this.value = 'INF';
	}

	terse(h_prefixes) {
		return '"INF"^^'+KT_XSD_DOUBLE.terse(h_prefixes);
	}
} Object.assign(Literal_PositiveInfinity.prototype, {
	isInfinite: true,
});

class Literal_NegativeInfinity extends Literal_Double {
	constructor() {
		super(-Infinity);
		this.value = '-INF';
	}

	terse(h_prefixes) {
		return '"-INF"^^'+KT_XSD_DOUBLE.terse(h_prefixes);
	}
} Object.assign(Literal_NegativeInfinity.prototype, {
	isInfinite: true,
});

class Literal_NaN extends Literal_Double {
	constructor() {
		super(NaN);
		this.value = 'NaN';
	}

	terse(h_prefixes) {
		return '"NaN"^^'+KT_XSD_DOUBLE.terse(h_prefixes);
	}
} Object.assign(Literal_NaN.prototype, {
	isNaN: true,
});


function BlankNode(s_value, b_anonymous=false) {
	this.value = s_value;
	this.isAnonymous = b_anonymous;
} BlankNode.prototype = Object.assign(
	Object.create(GenericTerm.prototype), {
		termType: 'BlankNode',
		isBlankNode: true,

		concise() {
			return '_:'+this.value;
		},

		terse() {
			return '_:'+this.value;
		},

		verbose() {
			return '_:'+this.value;
		},

		isolate() {
			return {
				termType: 'BlankNode',
				value: this.value,
			};
		},
	});


function EphemeralBlankNode() {}
EphemeralBlankNode.prototype = Object.assign(
	Object.create(BlankNode.prototype), {
		isAnonymous: true,
		isEphemeral: true,

		concise() {
			return '_:#'+this.value;
		},

		terse() {
			return '[]';
		},

		verbose() {
			return '_:'+this.value;
		},

		isolate() {
			return {
				termType: 'BlankNode',
				value: this.value,
			};
		},

		equals() {
			return false;
		},
	});
Object.defineProperty(EphemeralBlankNode.prototype, 'value', {
	get() {
		return '_'+uuid_v4();
	},
});

class Variable extends GenericTerm {
	constructor(s_label) {
		super();
		this.value = s_label;
	}

	concise() {
		return '?'+this.value;
	}

	terse() {
		throw new Error(`Cannot call .terse() on 'Variable' term type`);
	}

	verbose() {
		throw new Error(`Cannot call .verbose() on 'Variable' term type`);
	}

	isolate() {
		return {
			termType: 'Variable',
			value: this.value,
		};
	}
} Object.assign(Variable.prototype, {
	termType: 'Variable',
	isVariable: true,
});


function DefaultGraph() {}
DefaultGraph.prototype = Object.assign(
	Object.create(GenericTerm.prototype), {
		value: '',
		termType: 'DefaultGraph',
		isDefaultGraph: true,

		concise() {
			return '*';
		},

		terse() {
			return '';
		},

		verbose() {
			return '';
		},

		isolate() {
			return {
				termType: 'DefaultGraph',
				value: '',
			};
		},
	});

function NoGraph() {}
NoGraph.prototype = Object.assign(
	Object.create(GenericTerm.prototype), {
		value: '',
		termType: 'NoGraph',

		concise() {
			return '';
		},

		terse() {
			return '';
		},

		verbose() {
			return '';
		},

		isolate() {
			return {
				termType: 'NoGraph',
				value: '',
			};
		},
	});

const KT_DEFAULT_GRAPH = new DefaultGraph();
function Quad(h_subject, h_predicate, h_object, h_graph=KT_DEFAULT_GRAPH) {
	this.subject = h_subject;
	this.predicate = h_predicate;
	this.object = h_object;
	this.graph = h_graph;
} Object.assign(Quad.prototype, {
	isGraphyQuad: true,

	equals(z_other) {
		return z_other
			? this === z_other
				|| (this.object.equals(z_other.object)
					&& this.subject.equals(z_other.subject)
					&& this.predicate.equals(z_other.predicate)
					&& this.graph.equals(z_other.graph))
			: false;
	},

	valueOf() {
		return this.verbose();
	},

	concise(h_prefixes={}) {
		return [
			this.subject.concise(h_prefixes),
			this.predicate.concise(h_prefixes),
			this.object.concise(h_prefixes),
			this.graph.concise(h_prefixes),
		];
	},

	terse(h_prefixes) {
		let b_default_graph = this.graph.isDefaultGraph;
		return (b_default_graph? '': this.graph.terse(h_prefixes)+' { ')
			+this.subject.terse(h_prefixes)
			+' '+this.predicate.terse(h_prefixes)
			+' '+this.object.terse(h_prefixes)+' .'
			+(b_default_graph? '': ' }');
	},

	verbose() {
		return this.subject.verbose()
			+' '+this.predicate.verbose()
			+' '+this.object.verbose()
			+' '+(this.graph.isDefaultGraph? '': this.graph.verbose()+' ')+'.';
	},

	isolate() {
		return {
			subject: this.subject.isolate(),
			predicate: this.predicate.isolate(),
			object: this.object.isolate(),
			graph: this.graph.isolate(),
		};
	},
});



let g_raw = {
	namedNode(p_iri) {
		return new NamedNode(p_iri);
	},

	blankNode(s_label, b_anonymous) {
		return new BlankNode(s_label, b_anonymous);
	},

	literal(s_value) {
		return new RawLiteral(s_value);
	},

	defaultGraph() {
		return new DefaultGraph();
	},

	quad(kt_subject, kt_predicate, kt_object, kt_graph) {
		return new Quad(kt_subject, kt_predicate, kt_object, kt_graph || KT_DEFAULT_GRAPH);
	},

	integer(w) {
		return Literal_Integer.from(w);
	},

	double(w) {
		return Literal_Double.from(w);
	},

	decimal(w) {
		return Literal_Decimal.from(w);
	},

	boolean(w) {
		return new Literal_Boolean(w);
	},

};


const factory = module.exports = {
	concise,

	adopt(dc_factory) {
		let dc_extend = Object.create(dc_factory);
		let b_use_extend = false;

		if('function' !== typeof dc_factory.boolean) {
			let kt_xsd_boolean = dc_factory.namedNode('http://www.w3.org/2001/XMLSchema#boolean');
			dc_extend.boolean = b_value => dc_factory.literal(b_value, kt_xsd_boolean);
			b_use_extend = true;
		}

		if('function' !== typeof dc_factory.double) {
			let kt_xsd_double = dc_factory.namedNode('http://www.w3.org/2001/XMLSchema#double');
			dc_extend.double = s_value => dc_factory.double(s_value, kt_xsd_double);
			b_use_extend = true;
		}

		if('function' !== typeof dc_factory.decimal) {
			let kt_xsd_decimal = dc_factory.namedNode('http://www.w3.org/2001/XMLSchema#decimal');
			dc_extend.decimal = s_value => dc_factory.decimal(s_value, kt_xsd_decimal);
			b_use_extend = true;
		}

		if('function' !== typeof dc_factory.integer) {
			let kt_xsd_integer = dc_factory.namedNode('http://www.w3.org/2001/XMLSchema#integer');
			dc_extend.integer = s_value => dc_factory.integer(s_value, kt_xsd_integer);
			b_use_extend = true;
		}

		if('function' !== typeof dc_factory.simpleLiteral) {
			dc_extend.simpleLiteral = s_value => dc_factory.literal(s_value);
			b_use_extend = true;
		}

		if('function' !== typeof dc_factory.languagedLiteral) {
			dc_extend.languagedLiteral = (s_value, s_lang) => dc_factory.literal(s_value, s_lang);
			b_use_extend = true;
		}

		if('function' !== typeof dc_factory.datatypedLiteral) {
			dc_extend.datatypedLiteral = (s_value, kt_datatype) => dc_factory.literal(s_value, kt_datatype);
			b_use_extend = true;
		}

		if(b_use_extend) {
			return dc_extend;
		}
		else {
			return dc_factory;
		}
	},

	raw: g_raw,
	unfiltered: {
		...g_raw,
		literal(s_value, z_datatype_or_lang) {
			if(!z_datatype_or_lang || KT_XSD_STRING.equals(z_datatype_or_lang)) {
				return new SimpleLiteral(s_value);
			}
			else if('string' === typeof z_datatype_or_lang) {
				return new LanguagedLiteral(s_value, z_datatype_or_lang);
			}
			else if(KT_XSD_STRING.equals(z_datatype_or_lang)) {
				return new SimpleLiteral(s_value);
			}
			else {
				return new ExplicitlyDatatypedLiteral(s_value, z_datatype_or_lang);
			}
		},

		simpleLiteral(s_value) {
			return new SimpleLiteral(s_value);
		},

		languagedLiteral(s_value, s_language) {
			return new LanguagedLiteral(s_value, s_language);
		},

		datatypedLiteral(s_value, kt_datatype) {
			if(KT_XSD_STRING.equals(kt_datatype)) {
				return new SimpleLiteral(s_value);
			}
			else {
				return new ExplicitlyDatatypedLiteral(s_value, kt_datatype);
			}
		},
	},

	number(x) {
		// not finite or not a number
		if('number' === typeof x && (!Number.isFinite(x) || Number.isNaN(x))) {
			return factory.double(x);
		}
		// integer or bigint
		else if(Number.isInteger(x) || 'bigint' === typeof x) {  // eslint-disable-line valid-typeof
			return factory.integer(x);
		}
		// non-integer
		else {
			return factory.decimal(x);
		}
	},

	date(dt) {
		return factory.literal(dt.toISOString().replace(/T.+$/, 'Z'), KT_XSD_DATE);
	},

	dateTime(dt) {
		return factory.literal(dt.toISOString(), KT_XSD_DATETIME);
	},

	namedNode(p_iri) {
		return new NamedNode(p_iri);
	},

	ephemeral() {
		return new EphemeralBlankNode();
	},

	// @deprecated
	anonymous() {
		return new EphemeralBlankNode();
	},

	blankNode(z_label) {
		// no label given, generate a UUID
		if(!z_label) {
			// eslint-disable-next-line no-undef
			return new BlankNode('_'+uuid_v4(), true);
		}
		// label given
		else if('string' === typeof z_label) {
			return new BlankNode(z_label);
		}

		throw new TypeError(`factory.blankNode(label) expects 'label' parameter to be falsy or a string; instead found: ${z_label}`);
	},

	literal(s_value, z_datatype_or_lang) {
		if(!z_datatype_or_lang || KT_XSD_STRING.equals(z_datatype_or_lang)) {
			return new SimpleLiteral(s_value);
		}
		else if('string' === typeof z_datatype_or_lang) {
			return new LanguagedLiteral(s_value, z_datatype_or_lang);
		}
		else {
			return new ExplicitlyDatatypedLiteral(s_value, z_datatype_or_lang);
		}
	},

	integer(w_value) {
		let s_type = typeof w_value;

		// a number was given
		if('number' === s_type) {
			// not a finite number
			if(!Number.isFinite(w_value)) {
				// NaN
				if(Number.isNaN(w_value)) {
					throw new Error('XSD integer cannot encode NaN. Try using double');
				}

				throw new Error('XSD integer cannot encode +/-infinity. Try using double');
			}
			// not an integer
			else if(!Number.isInteger(w_value)) {
				throw new Error('Number is not an integer: '+w_value);
			}

			return new Literal_Integer(w_value);
		}
		// string
		else if('string' === s_type) {
			// empty string
			if('' === w_value) {
				throw new Error('Refusing to serialize empty string as xsd:integer');
			}

			// parse to number
			let x_value = +w_value;

			// failed to parse or not an integer
			if(Number.isNaN(x_value) || !Number.isInteger(x_value)) {
				throw new Error('Invalid integer string: '+w_value);
			}

			return new Literal_Integer(x_value);
		}
		// undefined
		else if('undefined' === s_type) {
			throw new Error('Refusing to serialize undefined value as xsd:integer');
		}
		// other
		else {
			// null
			if(null === w_value) {
				throw new Error('Refusing to serialize null value as xsd:integer');
			}

			// invalid
			throw new Error('XSD integer expects a number type or integer string');
		}
	},
	double(w_value) {
		let s_type = typeof w_value;

		// a number was given
		if('number' === s_type) {
			// not a finite number
			if(!Number.isFinite(w_value)) {
				// NaN
				if(Number.isNaN(w_value)) {
					return new Literal_NaN();
				}

				return w_value > 0
					? new Literal_PositiveInfinity()
					: new Literal_NegativeInfinity();
			}

			return new Literal_Double(w_value);
		}
		// string
		else if('string' === s_type) {
			// empty string
			if('' === w_value) {
				throw new Error('Refusing to serialize empty string as xsd:double');
			}

			// parse to number
			let x_value = +w_value;

			// failed to parse
			if(Number.isNaN(x_value)) {
				throw new Error('Invalid decimal string: '+w_value);
			}

			return new Literal_Double(x_value);
		}
		// undefined
		else if('undefined' === s_type) {
			throw new Error('Refusing to serialize undefined value as xsd:double');
		}
		// other
		else {
			// null
			if(null === w_value) {
				throw new Error('Refusing to serialize null value as xsd:double');
			}

			// invalid
			throw new Error('XSD double expects a number type or double string');
		}
	},
	decimal(w_value) {
		let s_type = typeof w_value;

		// a number was given
		if('number' === s_type) {
			// not a finite number
			if(!Number.isFinite(w_value)) {
				// NaN
				if(Number.isNaN(w_value)) {
					throw new Error('XSD decimal cannot encode NaN. Try using double');
				}

				throw new Error('XSD decimal cannot encode +/-infinity. Try using double');
			}

			return new Literal_Decimal(w_value);
		}
		// string
		else if('string' === s_type) {
			// empty string
			if('' === w_value) {
				throw new Error('Refusing to serialize empty string as xsd:decimal');
			}

			// parse to number
			let x_value = +w_value;

			// failed to parse
			if(Number.isNaN(x_value)) {
				throw new Error('Invalid decimal string: '+w_value);
			}

			return new Literal_Decimal(x_value);
		}
		// undefined
		else if('undefined' === s_type) {
			throw new Error('Refusing to serialize undefined value as xsd:decimal');
		}
		// other
		else {
			// null
			if(null === w_value) {
				throw new Error('Refusing to serialize null value as xsd:decimal');
			}

			// invalid
			throw new Error('XSD decimal expects a number type or decimal string');
		}
	},
	boolean(w_value) {
		let s_type = typeof w_value;

		// boolean
		if('boolean' === s_type) {
			return new Literal_Boolean(w_value);
		}
		// number
		else if('number' === s_type) {
			// 1
			if(1 === w_value) {
				return new Literal_Boolean(true);
			}
			// 0
			else if(0 === w_value) {
				return new Literal_Boolean(false);
			}

			// invalid
			throw new Error(`Boolean value 'w_value' must be either a '1' or '0' if using numbers`);
		}
		// string
		else if('string' === s_type) {
			// truthy value
			if(RT_BOOLEAN_TRUE.test(w_value)) {
				return new Literal_Boolean(true);
			}
			// falsy value
			else if(RT_BOOLEAN_FALSE.test(w_value)) {
				return new Literal_Boolean(false);
			}

			// empty string
			if('' === w_value) {
				throw new Error('Refusing to serialize empty string as xsd:boolean');
			}

			// failed to parse
			throw new Error('Invalid boolean string: '+w_value);
		}
		// undefined
		else if('undefined' === s_type) {
			throw new Error('Refusing to serialize undefined value as xsd:boolean');
		}
		// other
		else {
			// null
			if(null === w_value) {
				throw new Error('Refusing to serialize null value as xsd:boolean');
			}

			// invalid
			throw new Error('XSD boolean expects a boolean type or boolean string');
		}
	},


	defaultGraph() {
		return new DefaultGraph();
	},

	variable(s_label) {
		return new Variable(s_label);
	},

	// warn
	triple(h_subject, h_predicate, h_object) {
		let e_stack = new Error('It is strongly encouraged to use .quad() instead of .triple()');
		console.warn(e_stack.stack.replace(/^(\s*)Error:/, '$1Warning:'));
		return new Quad(h_subject, h_predicate, h_object);
	},

	quad(h_subject, h_predicate, h_object, h_graph) {
		return new Quad(h_subject, h_predicate, h_object, h_graph || KT_DEFAULT_GRAPH);
	},

	term(z_term, w_prefixes) {
		// concise term
		if('string' === typeof z_term) {
			return factory.c1(z_term, w_prefixes);
		}
		// rdfjs term
		else {
			return factory.from.rdfjs_term(z_term);
		}
	},

	/**
	 * construct a term object from a concise term string
	 * @param  {c1_string} sc1_term - a representation of the term object to create
	 * @param  {Object} h_prefixes - mappings for prefixes
	 * @return {Term} - an RDFJS-compatible term object
	 */
	c1(sc1_term, h_prefixes={}) {
		// deduce term type
		switch(sc1_term[0]) {
			// datatyped literal
			case '^': {
				// find literal's contents delimiter
				let i_contents = sc1_term.indexOf('"');

				// no delimiter
				if(-1 === i_contents) {
					throw new Error(`Invalid concise-term string, no content literal delimiter found: '${sc1_term}'`);
				}

				// extract datatype
				let s_datatype = sc1_term.slice(1, i_contents);

				// make term
				return factory.literal(sc1_term.slice(i_contents+1), factory.c1_node_explicit(s_datatype, h_prefixes));
			}

			// languaged literal
			case '@': {
				// find literal's contents delimiter
				let i_contents = sc1_term.indexOf('"');

				// no delimiter
				if(-1 === i_contents) {
					throw new Error(`Invalid concise-term string, no content literal delimiter found: '${sc1_term}'`);
				}

				// extract language
				let s_language = sc1_term.slice(1, i_contents);

				// make term
				return factory.literal(sc1_term.slice(i_contents+1), s_language);
			}

			// simple literal
			case '"': {
				// make term
				return factory.literal(sc1_term.slice(1));
			}

			// prefixed name
			default: return factory.c1_node(sc1_term, h_prefixes);
		}
	},

	// construct a term object from a concise term string for nodes
	c1_node(sc1_node, h_prefixes={}) {
		// rdf:type shortcut
		if('a' === sc1_node) return KT_RDF_TYPE;

		// default graph
		if('*' === sc1_node) return factory.defaultGraph();

		// blank node
		if('_' === sc1_node[0]) {
			if(':' !== sc1_node[1]) throw new Error(`Invliad concise-term string, prefixes are not allowed to start with an underscore: '${sc1_node}'`);

			// interpret ephemeral hint
			if('#' === sc1_node[2] || 2 === sc1_node.length) return factory.ephemeral();

			// create blank node
			return factory.blankNode(sc1_node.slice(2));
		}

		// other
		return factory.c1_node_explicit(sc1_node, h_prefixes);
	},

	// construct a named node
	c1_named_node(sc1_node, h_prefixes={}) {
		// rdf:type shortcut
		if('a' === sc1_node) return KT_RDF_TYPE;

		// other
		return factory.c1_node_explicit(sc1_node, h_prefixes);
	},

	// construct a term object from a concise term string for nodes (no shortcuts)
	c1_node_explicit(sc1_node, h_prefixes={}) {
		// deduce term type
		switch(sc1_node[0]) {
			// iri
			case '>': return factory.namedNode(sc1_node.slice(1));

			// invalid concise-term string
			case '<': throw new Error(`Whoops! It looks like this concise-term string starts with a '<' character. Remember to use '>' if you are trying to make an absolute IRI reference.\nInvalid concise-term string '${sc1_node}'`);
			case '`': throw new Error(`The backtick character '\`' is reserved for concise-struct key directives and should not be used in the object position.\nInvalid concise-term string '${sc1_node}'`);

			// prefixed name
			default: return this.c1_prefixed_node(sc1_node, h_prefixes);
		}
	},

	// construct a term object from a concise term string for prefixed nodes
	c1_prefixed_node(sc1_node, h_prefixes={}) {
		// find prefix delimiter
		let i_colon = sc1_node.indexOf(':');

		// no delimter; invalid concise-term string for node
		if(-1 === i_colon) throw new Error(`A relative or prefixed node must include a ':' character. \nInvalid concise-term string for node: '${sc1_node}'`);

		// prefix id
		let s_prefix_id = sc1_node.slice(0, i_colon);

		// suffix
		let s_suffix = sc1_node.slice(i_colon+1);

		// find prefix in hash
		if(s_prefix_id in h_prefixes) {
			return factory.namedNode(h_prefixes[s_prefix_id]+s_suffix);
		}
		// prefix not exists
		else {
			throw new Error(`Prefix not defined: '${s_prefix_id}'`);
		}
	},

	c1_to_nt,

	* quads(hc4_quads, h_prefixes={}) {
		for(let sc1_graph in hc4_quads) {
			yield* factory.triples(hc4_quads[sc1_graph], h_prefixes, sc1_graph);
		}
	},

	* triples(hc3_triples, h_prefixes={}, sc1_graph='*') {
		let k_graph = factory.c1(sc1_graph, h_prefixes);
		for(let sc1_subject in hc3_triples) {
			let k_subject = factory.c1(sc1_subject, h_prefixes);
			let hc2_pairs = hc3_triples[sc1_subject];

			yield* factory.pairs(k_graph, k_subject, hc2_pairs, h_prefixes);
		}
	},

	* pairs(k_graph, k_subject, hc2_pairs, h_prefixes={}) {
		for(let sc1_predicate in hc2_pairs) {
			let k_predicate = factory.c1(sc1_predicate, h_prefixes);
			let z_objects = hc2_pairs[sc1_predicate];

			yield* factory.objects(k_graph, k_subject, k_predicate, z_objects, h_prefixes);
		}
	},

	* collection(k_graph, k_subject, a_objects, h_prefixes={}) {
		// first item
		yield* factory.objects(k_graph, k_subject, KT_RDF_FIRST, a_objects[0], h_prefixes);

		// rest of items
		let a_rest = a_objects.slice(1);

		// no more
		if(!a_rest.length) {
			yield new Quad(k_subject, KT_RDF_REST, KT_RDF_NIL, k_graph);
		}
		// more remain
		else {
			// auto blank node
			let k_hop = factory.blankNode();

			// incoming triple
			yield new Quad(k_subject, KT_RDF_REST, k_hop, k_graph);

			// outgoing triples
			yield* factory.collection(k_graph, k_hop, a_rest, h_prefixes);
		}
	},

	* objects(k_graph, k_subject, k_predicate, z_objects, h_prefixes, b_nested=false) {
		// value type
		let s_type = typeof z_objects;
		switch(s_type) {
			// c1-string
			case 'string': {
				yield new Quad(k_subject, k_predicate, factory.c1(z_objects, h_prefixes), k_graph);
				break;
			}

			// number
			case 'number': {
				yield new Quad(k_subject, k_predicate, factory.number(z_objects), k_graph);
				break;
			}

			// object
			case 'object': {
				// array
				if(Array.isArray(z_objects)) {
					// RDF collection
					if(b_nested) {
						// auto blank node
						let k_hop = factory.blankNode();

						// incoming triple
						yield new Quad(k_subject, k_predicate, k_hop, k_graph);

						// outgoing triple
						yield* factory.collection(k_graph, k_hop, z_objects, h_prefixes);
					}
					// list of objects
					else {
						for(let z_item of z_objects) {
							yield* factory.objects(k_graph, k_subject, k_predicate, z_item, h_prefixes, true);
						}
					}
				}
				// simple object
				else {
					// auto blank node
					let k_hop = factory.blankNode();

					// incoming triple
					yield new Quad(k_subject, k_predicate, k_hop, k_graph);

					// outgoing triples
					yield* factory.pairs(k_graph, k_hop, z_objects, h_prefixes);
				}
				break;
			}

			// other
			default: {
				throw new Error(`invalid object type: ${typeof z_objects}`);
			}
		}
	},

	from: {
		term(z_term) {
			if(z_term.isGraphyTerm) return z_term;

			return factory.from.rdfjs_term(z_term);
		},

		quad(g_quad) {
			if(g_quad.isGraphyQuad) return g_quad;

			let g_from = factory.from;
			return new Quad(
				g_from.rdfjs_term(g_quad.subject),
				g_from.rdfjs_term(g_quad.predicate),
				g_from.rdfjs_term(g_quad.object),
				g_quad.graph? g_from.rdfjs_term(g_quad.graph): KT_DEFAULT_GRAPH,
			);
		},

		rdfjs_term(g_term) {
			switch(g_term.termType) {
				case 'NamedNode': return new NamedNode(g_term.value);
				case 'BlankNode': return new BlankNode(g_term.value);
				case 'Literal': return factory.literal(g_term.value, g_term.language
					? g_term.language
					: (g_term.datatype
						? new NamedNode(g_term.datatype.value)
						: null));
				case 'DefaultGraph': return new DefaultGraph();
				default: {
					throw new TypeError(`invalid termType: ${g_term.termType}`);
				}
			}
		},

		sparql_result(g_term) {
			switch(g_term.type) {
				case 'uri': {
					return new NamedNode(g_term.value);
				}

				case 'literal':
				case 'typed-literal': {
					if('xml:lang' in g_term) {
						return new LanguagedLiteral(g_term.value, g_term['xml:lang']);
					}
					else if('datatype' in g_term && 'http://www.w3.org/2001/XMLSchema#string' !== g_term.datatype) {
						return new ExplicitlyDatatypedLiteral(g_term.value, new NamedNode(g_term.datatype));
					}
					else {
						return new SimpleLiteral(g_term.value);
					}
				}

				case 'bnode': {
					return new BlankNode(g_term.value);
				}

				default: {
					throw new Error(`unexpected SPARQL Result JSON Format Term type: ${g_term.type}`);
				}
			}
		},
	},

	to: {
		boolean: s_boolean => Literal_Boolean.from(s_boolean),
		integer: s_integer => Literal_Integer.from(s_integer),
		decimal: s_decimal => Literal_Decimal.from(s_decimal),
		double: s_double => Literal_Double.from(s_double),
	},


	/**
	 * @param  {Object} gc_comment -
	 * @return {string} a `concise-term string` directive to be used as a key in `concise-term structs`
	 * 	in order to write a comment to the document (only works with supporting serializers)
	 */
	comment(gc_comment={}) {
		return `\`[${uuid_v4()}]${JSON.stringify({...gc_comment, type:'comment'})}`;
	},

	/**
	 * @param  {integer} [line_count=1] - number of newlines to insert
	 * @return {string} a `concise-term string` directive to be used as a key in `concise-term structs`
	 * 	in order to write the given number of newlines to the document (only works with supporting serializers)
	 */
	newlines() {
		// if(!Number.isInteger(n_line_count)) throw new TypeError('graphy/core.data.factory#newlines() expects `line_count` argument to be an integer');
		return `\`[${uuid_v4()}]{"type":"newlines"}`;
	},

	/**
	 * @param {string} s_key - key that identifies which aspect to configure. e.g., 'lists'
	 * @return {string} a `concise-term string` directive to be used as a key in `concise-term structs`
	 * 	in order to write the given number of newlines to the document (only works with supporting serializers)
	 */
	config(s_key) {
		if('string' !== typeof s_key) throw new TypeError(`Expected 'key' argument to be a string, instead found ${typeof s_key}`);
		return `\`[${uuid_v4()}]{"type":"config","value":${JSON.stringify(s_key)}}`;
	},

	/**
	 * @param {AnyQuad} g_quad - quad to hash
	 * @return {string} a sha256 hash of the quad
	 */
	hash(g_quad) {
		// normalize quad
		let k_quad = factory.from.quad(g_quad);

		// create hash
		let d_hash = crypto.createHash('sha256');

		// verbose quad
		d_hash.update(k_quad.verbose());

		// return hash string
		return d_hash.digest('hex');
	},


	cache_prefixes,
	cachePrefixes: cache_prefixes,
	terse,

	clean_iri,
	cleanIri: clean_iri,

	$_PREFIX_CACHE,
};

Object.assign(factory, {
	c3: factory.triples,
	c4: factory.quads,
	fromTerm: factory.from.term,
	fromQuad: factory.from.quad,
});
