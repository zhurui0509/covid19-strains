


const uri = require('uri-js');
const string_decoder = require('string_decoder');

const stream = require('@graphy/core.iso.stream');
const factory = require('@graphy/core.data.factory');
const quad = k => factory.quad(k._kt_subject, k._kt_predicate, k._kt_object, k._kt_graph);

// eslint-disable-next-line no-misleading-character-class
const RT_PREFIXED_NAME_NAMESPACE_VALID = /^([A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u{02ff}\u{0370}-\u{037d}\u{037f}-\u{1fff}\u{200c}-\u{200d}\u{2070}-\u{218f}\u{2c00}-\u{2fef}\u{3001}-\u{d7ff}\u{f900}-\u{fdcf}\u{fdf0}-\u{fffd}\u{10000}-\u{effff}]([A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u{02ff}\u{0370}-\u{037d}\u{037f}-\u{1fff}\u{200c}-\u{200d}\u{2070}-\u{218f}\u{2c00}-\u{2fef}\u{3001}-\u{d7ff}\u{f900}-\u{fdcf}\u{fdf0}-\u{fffd}\u{10000}-\u{effff}_\-0-9\xb7\u{0300}-\u{036f}\u{203f}-\u{2040}.]*[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u{02ff}\u{0370}-\u{037d}\u{037f}-\u{1fff}\u{200c}-\u{200d}\u{2070}-\u{218f}\u{2c00}-\u{2fef}\u{3001}-\u{d7ff}\u{f900}-\u{fdcf}\u{fdf0}-\u{fffd}\u{10000}-\u{effff}_\-0-9\xb7\u{0300}-\u{036f}\u{203f}-\u{2040}])?)?$/u;
// eslint-disable-next-line no-misleading-character-class
const RT_PREFIXED_NAME_LOCAL_NAME_VALID = /^([A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u{02ff}\u{0370}-\u{037d}\u{037f}-\u{1fff}\u{200c}-\u{200d}\u{2070}-\u{218f}\u{2c00}-\u{2fef}\u{3001}-\u{d7ff}\u{f900}-\u{fdcf}\u{fdf0}-\u{fffd}\u{10000}-\u{effff}_:0-9]|%[A-Fa-f0-9]{2}|\\[_~.\-!$&'()*+,;=/?#@%])(([A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u{02ff}\u{0370}-\u{037d}\u{037f}-\u{1fff}\u{200c}-\u{200d}\u{2070}-\u{218f}\u{2c00}-\u{2fef}\u{3001}-\u{d7ff}\u{f900}-\u{fdcf}\u{fdf0}-\u{fffd}\u{10000}-\u{effff}_\-0-9\xb7\u{0300}-\u{036f}\u{203f}-\u{2040}.:]|%[A-Fa-f0-9]{2}|\\[_~.\-!$&'()*+,;=/?#@%])*([A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u{02ff}\u{0370}-\u{037d}\u{037f}-\u{1fff}\u{200c}-\u{200d}\u{2070}-\u{218f}\u{2c00}-\u{2fef}\u{3001}-\u{d7ff}\u{f900}-\u{fdcf}\u{fdf0}-\u{fffd}\u{10000}-\u{effff}_\-0-9\xb7\u{0300}-\u{036f}\u{203f}-\u{2040}:]|%[A-Fa-f0-9]{2}|\\[_~.\-!$&'()*+,;=/?#@%]))?$/u;
// eslint-disable-next-line no-misleading-character-class
const RT_BLANK_NODE_VALID = /^[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u{02ff}\u{0370}-\u{037d}\u{037f}-\u{1fff}\u{200c}-\u{200d}\u{2070}-\u{218f}\u{2c00}-\u{2fef}\u{3001}-\u{d7ff}\u{f900}-\u{fdcf}\u{fdf0}-\u{fffd}\u{10000}-\u{effff}_0-9]([A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u{02ff}\u{0370}-\u{037d}\u{037f}-\u{1fff}\u{200c}-\u{200d}\u{2070}-\u{218f}\u{2c00}-\u{2fef}\u{3001}-\u{d7ff}\u{f900}-\u{fdcf}\u{fdf0}-\u{fffd}\u{10000}-\u{effff}_\-0-9\xb7\u{0300}-\u{036f}\u{203f}-\u{2040}.]*[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u{02ff}\u{0370}-\u{037d}\u{037f}-\u{1fff}\u{200c}-\u{200d}\u{2070}-\u{218f}\u{2c00}-\u{2fef}\u{3001}-\u{d7ff}\u{f900}-\u{fdcf}\u{fdf0}-\u{fffd}\u{10000}-\u{effff}_\-0-9\xb7\u{0300}-\u{036f}\u{203f}-\u{2040}])?$/u;
const RT_NAMED_NODE_VALID = /^([^\0-\x20<>"{}|^`\\]|\\u[A-Fa-f0-9]{4}|\\U[A-Fa-f0-9]{8})*$/;
const RT_NAMED_NODE_ESCAPELESS_VALID = /^([^\0-\x20<>"{}|^`])*$/;

const RT_LITERAL_CONTENTS_VALID = /^(?:[^\\]|\\[tbnrf"'\\]|\\u[A-Fa-f0-9]{4}|\\U[A-Fa-f0-9]{8})*$/;

const R_UNICODE_ANY = /\\u([0-9A-Fa-f]{4})|\\U([0-9A-Fa-f]{8})/g;

const F_REPLACE_UNICODE_ANY = 	(s_, s_4, s_8) => String.fromCodePoint(parseInt(s_4 || s_8, 16));

const OPHOP = Object.prototype.hasOwnProperty;



const R_PREFIXED_NAME_QUICK = /([A-Za-z][A-Za-z0-9_-]*)?:([A-Za-z_0-9:][A-Za-z0-9_:-]*)(?:\s+|(?=\.?[<[("';,)\]#]|\.[\s\0]))/y;


const R_PREFIXED_NAME_ESCAPELESS = /([^\s#@<[("':_][^\s#@<[("':]*)?:((?:[^\s#@<[("'.;,)\]\\](?:[^\s#@<[("';,)\]\\]*[^\s#@<[("'.;,)\]\\])?)?)(?:\s+|(?=\.?[<[("';,)\]#]|\.[\s\0]))/y;



const R_PREFIXED_NAME = /([^\s#@<[("':_][^\s#@<[("':]*)?:((?:(?:[^\s#@<[("'.;,)\]\\]|\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\s"]))(?:(?:[^\s#@<[("';,)\]\\]|\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\s"]))*(?:[^\s#@<[("'.;,)\]\\]|\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\s"])))?)?)(?:\s+|(?=\.?[<[("';,)\]#]|\.[\s\0]))/y;

const R_PN_LOCAL_ESCAPES = /\\(.)/g;


const R_BLANK_NODE_LABEL = /_:(.(?:[^\s:<;,)\]#]*[^\s:<.;,)\]#])?)(?:\s+|(?=[<:,;\])#]))/y;
const R_BLANK_NODE_LABEL_TERMINAL = /_:(.(?:[^\s:<;,)\]#]*[^\s:<.;,)\]#])?)(?:\s+|(?=\.?[<:,;\])#])|(?=\.[\s@#<({[}]))/y;

const R_IRIREF_ESCAPELESS = /<([^\\>]*)>\s*/y;
const R_IRIREF = /<([^>]*)>\s*/y;

const R_NUMERIC_LITERAL = /([+-]?(?:[0-9]+(\.[0-9]+)?|(\.[0-9]+))(\.?[eE][+-]?[0-9]+)?)(?:\s+|(?=\.[^eE0-9]|[;,)\]]))/y;
const R_BOOLEAN_LITERAL = /(?:(true|TRUE)|false|FALSE)\s*/y;
const R_A = /a(?:\s+|(?=[[("'<#]))/y;

const R_DOUBLE_CARET = /\^\^/y;
const R_WS = /\s*/y;
const R_LANGTAG = /@([A-Za-z]+(?:-[A-Za-z0-9-]+)*)(?:\s+|(?=[.,;\])#]))/y;

const R_PREFIX_KEYWORD = /(?:(@prefix)|[pP][rR][eE][fF][iI][xX])\s*/y;
const R_PREFIX_ID = /([^#:]*):\s*/iy;
const R_BASE_KEYWORD = /(?:(@base)|[bB][aA][sS][eE])\s*/y;


const R_COMMENT = /(#[^\n]*\n\s*)+/y;

const RT_IRI_ABSOLUTE = /^[A-Za-z][A-Za-z0-9.\-+]*:/;
const R_RELATIVE_URI = /^(\/[^?#]+)([?#].*)?$/;
const R_BASE_IRI = /^((([A-Za-z0-9.\-+]*:\/)?\/[^/>]*)?(\/(?:[^/>]*\/)*)?[^>]*)$/;

const R_ANONYMOUS_BLANK_NODE = /\[\s*\]\s*/y;
const R_CHAR_BLANK_NODE = /\[(?:\s+|(?=[^\]]))/y;
const R_CHAR_COLLECTION = /\(\s*/y;

const R_CHAR_KET = /\]\s*/y;


const R_CHAR_STOP = /\.\s*/y;



const R_STRLIT_SHORT_DOUBLE_BREAK = /[\\"\r\n]/g;
const R_STRLIT_SHORT_SINGLE_BREAK = /[\\'\r\n]/g;

const R_STRLIT_LONG_DOUBLE_UNFINISHED_TERM = /"{1,2}$/g;
const R_STRLIT_LONG_SINGLE_UNFINISHED_TERM = /'{1,2}$/g;

const R_STRLIT_LONG_DOUBLE_BREAK = /(\\|""")/g;
const R_STRLIT_LONG_SINGLE_BREAK = /(\\|''')/g;


const F_REPLACE_STRLIT_CONTENTS = (s_, s_whitespace, s_auto, s_4, s_8, s_invalid) => {
	if(s_whitespace) {
		switch(s_whitespace) {
			case 't': return '\t';
			case 'n': return '\n';
			case 'r': return '\r';
			case 'f': return '\f';
			case 'b': return '\b';
			default: {
				console.assert(`bad regex escape char mapping: '${s_whitespace}'`);
			}
		}
	}
	else if(s_auto) {
		return s_auto;
	}
	else if(s_4) {
		return String.fromCodePoint(parseInt(s_4, 16));
	}
	else if(s_8) {
		return String.fromCodePoint(parseInt(s_8, 16));
	}
	else if(s_invalid) {
		// pointless escape
		if('\\' === s_invalid[0]) {
				// // relaxed
				// return s_invalid[1];
			// if relaxed then return s_invalid, otherwise throw:
			throw new Error(`expected string_literal but invalid escape sequence within contents: '${s_invalid}'. failed to parse a valid token`);
		}
		// bad character
		else {
			throw new Error(`expected string_literal but invalid whitespace character within contents: ${JSON.stringify(s_invalid)}. failed to parse a valid token`);
		}
	}
	else {
		console.assert(`unexpected no match branch in escape sequence replace callback`);
	}
};


const R_STRLIT_SHORT_CONTENTS_ESCAPES_HARD = /(?:\\(?:([tnrfb])|([\\"'])|u([0-9A-Fa-f]{4})|U([0-9A-Fa-f]{8}))|([\r\n]|\\.))/g;
const R_STRLIT_SHORT_CONTENTS_ESCAPES_SOFT = /(?:\\(?:([tnrfb])|([\\"'])|u([0-9A-Fa-f]{4})|U([0-9A-Fa-f]{8}))|([\r\n]|\\[^uU]|\\u[^]{4}|\\U[^]{8}))/g;

const unescape_literal_short_hard = s_literal => s_literal
	.replace(R_STRLIT_SHORT_CONTENTS_ESCAPES_HARD, F_REPLACE_STRLIT_CONTENTS);

const unescape_literal_short_soft = (s_literal) => {
	let m_incomplete = R_STRLIT_ESCAPE_INCOMPLETE.exec(s_literal);

	// incomplete escape
	if(m_incomplete) {
		let i_safe = m_incomplete.index;

		// rewind
		return [
			s_literal.slice(0, i_safe)
				.replace(R_STRLIT_SHORT_CONTENTS_ESCAPES_SOFT, F_REPLACE_STRLIT_CONTENTS),
			s_literal.slice(i_safe),
		];
	}
	// done
	else {
		return [
			s_literal
				.replace(R_STRLIT_SHORT_CONTENTS_ESCAPES_SOFT, F_REPLACE_STRLIT_CONTENTS),
			'',
		];
	}
};


const R_STRLIT_LONG_CONTENTS_ESCAPES_HARD = /(?:\\(?:([tnrfb])|([\\"'])|u([0-9A-Fa-f]{4})|U([0-9A-Fa-f]{8}))|(\\.))/g;
const R_STRLIT_LONG_CONTENTS_ESCAPES_SOFT = /(?:\\(?:([tnrfb])|([\\"'])|u([0-9A-Fa-f]{4})|U([0-9A-Fa-f]{8}))|(\\[^uU]|\\u[^]{4}|\\U[^]{8}))/g;

const unescape_literal_long_hard = s_literal => s_literal
	.replace(R_STRLIT_LONG_CONTENTS_ESCAPES_HARD, F_REPLACE_STRLIT_CONTENTS);

const unescape_literal_long_soft = (s_literal) => {
	let m_incomplete = R_STRLIT_ESCAPE_INCOMPLETE.exec(s_literal);

	// incomplete escape
	if(m_incomplete) {
		let i_safe = m_incomplete.index;

		// rewind
		return [
			s_literal.slice(0, i_safe)
				.replace(R_STRLIT_LONG_CONTENTS_ESCAPES_SOFT, F_REPLACE_STRLIT_CONTENTS),
			s_literal.slice(i_safe),
		];
	}
	// done
	else {
		return [
			s_literal
				.replace(R_STRLIT_LONG_CONTENTS_ESCAPES_SOFT, F_REPLACE_STRLIT_CONTENTS),
			'',
		];
	}
};

// lookbehind regexes
const [
	R_STRLIT_ESCAPE_INCOMPLETE,
	R_STRLIT_SHORT_DOUBLE_TERM,
	R_STRLIT_SHORT_SINGLE_TERM,
	R_STRLIT_LONG_DOUBLE_TERM,
	R_STRLIT_LONG_SINGLE_TERM,
] = (() => {
	function RegExp_$lookbehind_polyfill(s_input) {
		let m_match = RegExp.prototype.exec.call(this, s_input);

		if(m_match) {
			let i_start = m_match[0].length - m_match[1].length;
			m_match.index += i_start;
			m_match[0] = m_match[0].slice(i_start);
		}

		return m_match;
	}
	let mk_lookbehind_regex = (() => {
		try {
			new RegExp('(?<!h)i');  // eslint-disable-line no-new
		}
		catch(e_compile) {
			return (f_lookbehind, r_polyfill, f_polyfill) => {
				r_polyfill.exec = f_polyfill;
				return r_polyfill;
			};
		}
		return f_lookbehind => f_lookbehind();
	})();
	return [
		// R_STRLIT_ESCAPE_INCOMPLETE
		mk_lookbehind_regex(
			() => new RegExp('(?<!(?:[^\\\\]|^)(?:\\\\\\\\)*\\\\)\\\\(|u[0-9A-Fa-f]{0,3}|U[0-9A-Fa-f]{0,7})$'),
			/^(?:(?:[^\\]|\\.)*)(\\(?:|u[0-9A-Fa-f]{0,3}|U[0-9A-Fa-f]{0,7}))$/,
			function RegExp_$lookbehind_polyfill_n(s_input) {
				let m_match = RegExp.prototype.exec.call(this, s_input);
				if(m_match) {
					m_match.index += m_match[0].length - m_match[1].length;
				}

				return m_match;
			},
		),
		// R_STRLIT_SHORT_DOUBLE_TERM
		mk_lookbehind_regex(
			() => new RegExp('(?<!(?:[^\\\\]|^)(?:\\\\\\\\)*\\\\)"\\s*', 'g'),
			/(?:[^\\"]|\\.)*("\s*)/y,
			RegExp_$lookbehind_polyfill,
		),
		// R_STRLIT_SHORT_SINGLE_TERM
		mk_lookbehind_regex(
			() => new RegExp('(?<!(?:[^\\\\]|^)(?:\\\\\\\\)*\\\\)\'\\s*', 'g'),
			/(?:[^\\']|\\.)*('\s*)/y,
			RegExp_$lookbehind_polyfill,
		),

		// R_STRLIT_LONG_DOUBLE_TERM
		mk_lookbehind_regex(
			() => new RegExp('(?<!(?:[^\\\\]|^)(?:\\\\\\\\)*\\\\)"""\\s*', 'g'),
			/(?:[^\\"]|\\.|""?(?!"))*("""\s*)/y,
			RegExp_$lookbehind_polyfill,
		),

		// R_STRLIT_LONG_SINGLE_TERM
		mk_lookbehind_regex(
			() => new RegExp('(?<!(?:[^\\\\]|^)(?:\\\\\\\\)*\\\\)\'\'\'\\s*', 'g'),
			/(?:[^\\']|\\.|''?(?!'))*('''\s*)/y,
			RegExp_$lookbehind_polyfill,
		),

	];
})();

const match_prefixed_name_quick = (s, i) => {
	R_PREFIXED_NAME_QUICK.lastIndex = i;
	return [R_PREFIXED_NAME_QUICK.exec(s), R_PREFIXED_NAME_QUICK.lastIndex];
};

const match_prefixed_name_escapeless = (s, i) => {
	R_PREFIXED_NAME_ESCAPELESS.lastIndex = i;
	return [R_PREFIXED_NAME_ESCAPELESS.exec(s), R_PREFIXED_NAME_ESCAPELESS.lastIndex];
};

const match_prefixed_name = (s, i) => {
	R_PREFIXED_NAME.lastIndex = i;
	return [R_PREFIXED_NAME.exec(s), R_PREFIXED_NAME.lastIndex];
};



function Reader$syntax_error(k_self, i, si_state, s_info) {
	let i_off = Math.min(i, Math.abs(i-15));

	let s = k_self.s;

	return k_self.error(`\n\`${s.substr(i_off, i_off+90).replace(/[\n\t]/g, ' ')}\`\n`
		+` ${' '.repeat(i-i_off)}^\n`
		+`expected ${si_state} ${s_info || ''}.  failed to parse a valid token starting at ${s[i]? '"'+s[i]+'"': '<<EOF>>'}`);
}



class Turtle_Reader extends stream.Transform {
	constructor(g_impls) {
		super({
			// do not decode strings into buffers
			decodeStrings: false,

			// accept strings as input on writable side
			writableObjectMode: false,

			// output quad objects on readable side
			readableObjectMode: true,

			// implementations
			flush: g_impls.flush,
			transform: g_impls.transform,
		});
	}

	// intercept pipe
	pipe(ds_out) {
		let ds_dst = ds_out;

		// non-object mode
		if(!ds_dst._writableState.objectMode) {
			// transform to JSON
			ds_out = stream.quads_to_json();
		}
		// yet object mode and graphy writable
		else if(ds_out.isGraphyWritable) {
			// transform to writable data events
			ds_out = stream.quads_to_writable();
		}

		// interim stream created
		if(ds_out !== ds_dst) {
			// forward output to super
			super.pipe(ds_out);

			// pipe outpu to destination
			return ds_out.pipe(ds_dst);
		}
		// forward as-is to super
		else {
			return super.pipe(ds_dst);
		}
	}
}


class Reader {
	constructor(g_config={}) {
		// impl-specific configs
		let {
			// input medium
			input: g_input=null,

			// a state to inherit
			state: g_state={},
		} = g_config;

		// inherit state from creator
		let {
			// index for anonymous blank node labels
			blank_node_index: i_anon=0,

			// prefix map
			prefixes: h_prefixes={},

			// blank node label map
			labels: h_labels={},
		} = g_state;


		let dc_factory = factory.adopt(g_config.dataFactory || g_config.data_factory || factory.unfiltered);

		let kt_default_graph = dc_factory.defaultGraph();

		// if data factory is not graphy, it might be returning the same object on each call to .defaultGraph()
		if(dc_factory !== factory.unfiltered) {
			// do not trust it, create a new object
			kt_default_graph = Object.create(kt_default_graph);
		}

		let kt_rdf_first = dc_factory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#first');

		let blankNode = dc_factory.blankNode;
		let namedNode = dc_factory.namedNode;

		this.emit_data = factory.unfiltered === dc_factory
			? function() {
				ds_transform.push(quad(this));
			}
			: function() {
				let g_quad = dc_factory.quad(this._kt_subject, this._kt_predicate, this._kt_object, this._kt_graph);
				ds_transform.push(g_quad);
			};

		// fields
		Object.assign(this, {
			// read index
			i: 0,

			// string buffer
			s: '',

			// string buffer length
			n: 0,

			// left-over string from previous data chunk
			pre: g_config.prepend || '',

			// debug state
			_b_debug: g_config.debug || false,

			// relax
			_b_relax: g_config.relax || false,

			// factory
			_dc_factory: dc_factory,

			// current reader state
			_f_state: this.statement,

			// map of current prefix ids => iris
			_h_prefixes: h_prefixes,


			// reader was destroyed by an error
			_b_destroyed: false,

			// current @base url
			_s_base_url: '',
			_s_base_url_scheme: '',
			_s_base_url_root: '',
			_s_base_url_path: '',

			// current data
			_kt_subject: null,
			_kt_predicate: kt_rdf_first,
			_kt_object: null,
			_kt_graph: kt_default_graph,
			_s_literal: '',

			// static terms
			_kt_rdf_type: dc_factory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
			_kt_rdf_first: kt_rdf_first,
			_kt_rdf_rest: dc_factory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#rest'),
			_kt_rdf_nil: dc_factory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#nil'),
			_kt_default_graph: kt_default_graph,

			// queue of nested subject, predicate, state for blanknodes and collections
			_a_nested: [],

			// hash to keep track of all blank node labels in use
			_h_labels: h_labels,

			// event routing
			event: this.emit,
			data: this.emit_data,

			// for restoring the original event callback when resuming paused stream
			restore_data: this.emit_data,

			// keep a queue of data events to hold onto until stream resumes (only happens in rare conditions)
			_a_queue_event: [],

			// helper states
			_b_expecting_full_stop: false,
			_s_temp_prefix_id: null,
			_b_trim_start: true,

			anonymous_blank_node: s_label => blankNode(s_label, true),

			// finds the next non-conflicting blank node label
			next_label() {
				let s_label = '';
				do {
					s_label = 'g'+(i_anon++);
				} while(this._h_labels[s_label]);

				// claim this label, and remember that we invented it
				this._h_labels[s_label] = 2;

				// return the label
				return s_label;
			},

			// what to do when reach eos
			eos: null,

			// which state to go to after end of statement
			after_end_of_statement: this.post_object,

			// maximum length of a token: defaults to 2048 => http://stackoverflow.com/a/417184/1641160
			_n_max_token_length: g_config.max_token_length || g_config.maxTokenLength || 2048,

			// maximum length of a string (overrides max_token_length): defaults to Infinity
			_n_max_string_length: g_config.max_string_length || g_config.maxStringLength || Infinity,

			// byte tracking
			_b_byte_tracking: g_config.byte_tracking || g_config.byteTracking || false,
			_nb_seen: 0,
			_nb_last: 0,
			_nb_curr: 0,
		});

		if(g_config.relaxed) {
			console.warn((new Error(`no such option 'relaxed'; did you mean 'relax' ?`)).stack.replace(/^Error:/, 'Warning:'));
		}
		if('validate' in g_config) {
			console.warn((new Error(`option 'validate' has been deprecated. Validation is now enabled by default. Use the 'relax' option if you wish to disable validation.`)).stack.replace(/^Error:/, 'Warning:'));
		}



		// term constructors
		Object.assign(this, !g_config.relax
			? {
				blank_node(s_label) {
					// test valid blank node label
					if(!RT_BLANK_NODE_VALID.test(s_label)) return this.error(`invalid blank node label: "${s_label}"`);

					// not first time use of label
					let z_label_state = this._h_labels[s_label];
					if(z_label_state) {
						// label was used previously by document and has no conflict
						if(1 === z_label_state) {}  // eslint-disable-line no-empty
						// label is in use by invention, this would cause a conflict
						else if(2 === z_label_state) {
							// so create a redirect mapping for this actual label & use it instead
							s_label = this._h_labels[s_label] = this.next_label();
						}
						// label already has a redirect mapping
						else {
							// use redirected label
							s_label = this._h_labels[s_label];
						}
					}
					// first time use of label
					else {
						// store label in hash so we avoid future collisions
						this._h_labels[s_label] = 1;
					}

					// make term
					return blankNode(s_label);
				},

				check_named_node(p_iri) {
					if(!RT_NAMED_NODE_VALID.test(p_iri)) return this.error(`invalid IRI: "${p_iri}"`);
					return namedNode(p_iri);
				},

				check_named_node_escapeless(p_iri) {
					if(!RT_NAMED_NODE_ESCAPELESS_VALID.test(p_iri)) return this.error(`invalid IRI: "${p_iri}"`);
					return namedNode(p_iri);
				},

				match_prefixed_name_quick(s, i) {
					R_PREFIXED_NAME_QUICK.lastIndex = i;
					return [R_PREFIXED_NAME_QUICK.exec(s), R_PREFIXED_NAME_QUICK.lastIndex];
				},

				match_prefixed_name_escapeless(s, i) {
					let [m_prefixed_name_e, im_prefixed_name_e] = match_prefixed_name_escapeless(s, i);
					if(m_prefixed_name_e) {
						// invalid local name
						if(!RT_PREFIXED_NAME_LOCAL_NAME_VALID.test(m_prefixed_name_e[2]) && m_prefixed_name_e[2]) {
							this.error(`invalid prefixed name local name: "${m_prefixed_name_e[2]}:"`);
							return;
						}
					}

					return [m_prefixed_name_e, im_prefixed_name_e];
				},

				match_prefixed_name(s, i) {
					let [m_prefixed_name, im_prefixed_name] = match_prefixed_name(s, i);
					if(m_prefixed_name) {
						// invalid local name
						if(!RT_PREFIXED_NAME_LOCAL_NAME_VALID.test(m_prefixed_name[2])) {
							this.error(`invalid prefixed name local name: "${m_prefixed_name[2]}:"`);
							return;
						}
					}

					return [m_prefixed_name, im_prefixed_name];
				},
			}
			: {
				// term constructors
				blank_node(s_label) {
					// not first time use of label
					let z_label_state = this._h_labels[s_label];
					if(z_label_state) {
						// label was used previously by document and has no conflict
						if(1 === z_label_state) {}  // eslint-disable-line no-empty
						// label is in use by invention, this would cause a conflict
						else if(2 === z_label_state) {
							// so create a redirect mapping for this actual label & use it instead
							s_label = this._h_labels[s_label] = this.next_label();
						}
						// label already has a redirect mapping
						else {
							// use redirected label
							s_label = this._h_labels[s_label];
						}
					}
					// first time use of label
					else {
						// store label in hash so we avoid future collisions
						this._h_labels[s_label] = 1;
					}

					// make term
					return blankNode(s_label);
				},

				check_named_node: namedNode,

				check_named_node_escapeless: namedNode,

				match_prefixed_name_escapeless,

				match_prefixed_name,
			});


		this.named_node = namedNode;

		this.prefixed_name = function(si_prefix, s_suffix) {
			return namedNode(h_prefixes[si_prefix] + s_suffix);
		};


		// oops -- user passed string into `base`
		if('string' === typeof g_config.base) {
			throw new TypeError(`invalid type 'string' was given for 'base' event listener: '${g_config.base}'\n`
				+`did you mean to use the 'base_uri' key instead?`);
		}

		// base uri
		let p_set_base_uri = g_config.base_uri || g_config.baseUri || g_config.baseURI || g_config.base_iri || g_config.baseIri || g_config.baseIRI;
		if(p_set_base_uri) {
			let m_base_iri = R_BASE_IRI.exec(p_set_base_uri);
			this._s_base_url = m_base_iri[1];
			this._s_base_url_root = m_base_iri[2] || '';
			this._s_base_url_scheme = m_base_iri[3] || '';
			this._s_base_url_path = m_base_iri[4] || '';
		}
		// not set; 'url' variant is
		else if(g_config.base_url || g_config.baseUrl || g_config.baseURL) {
			throw new Error(`invalid option: .base${g_config.base_url? '_url': g_config.baseUrl? 'Url': g_config.baseURL? 'URL': ''}; use the '.base_uri' key instead`);
		}

		// transform stream
		let ds_transform = this.transform = new Turtle_Reader({
			// on data event
			transform: (s_chunk, s_encoding, fke_chunk) => {
				// concatenate current chunk to previous chunk
				let s = this.s = this.pre + s_chunk;

				// cache chunk length
				this.n = s.length;

				// eat whitespace before token and reset index
				if(this._b_trim_start) {
					// consume whitespace (and incidentally reset index)
					R_WS.lastIndex = 0;
					R_WS.exec(s);
					this.i = R_WS.lastIndex;
				}
				// do not eat whitespace; start at beginning
				else {
					this.i = 0;
				}

				// resume parsing; no errors
				if(this.safe_parse(true)) {
					// emit progress event updates
					ds_transform.emit('progress', s_chunk.length);

					// done transforming this chunk
					fke_chunk();
				}
			},

			// once there's no more data to consume, invoke eof
			flush: (fke_flush) => {
				// now that input stream has ended, clean up remainder
				try {
					this.eof(1);
				}
				// read error occurred
				catch(e_eof) {
					// destroy self and stream
					this.destroy(e_eof);

					// exit gracefully
					return;
				}

				// no errors. done flushing, close read stream
				fke_flush();
			},
		});

		// when the writable side is piped into
		ds_transform.on('pipe', (ds_input) => {
			this._ds_input = ds_input;

			let b_byte_tracking = this._b_byte_tracking;

			// byte-tracking is disable & input stream has encoding option; ensure stream encoding is utf8
			if(!b_byte_tracking && 'function' === typeof ds_input.setEncoding) {
				ds_input.setEncoding('utf8');
			}
			// set decoding on write
			else {
				let f_write = ds_transform.write;
				let d_decoder = new string_decoder.StringDecoder('utf8');

				let f_write_track = (s_chunk, s_encoding, fk_write) => {
					// TODO: optimize by testing for multibyte chars and using string length instead?
					let nb_chunk = Buffer.from(s_chunk, 'utf8').length;
					this._nb_seen += nb_chunk;
					this._nb_last = nb_chunk;
					return f_write.call(ds_transform, s_chunk, s_encoding, fk_write);
				};

				let f_decode_write_track = (ab_chunk, s_encoding, fk_write) => {
					let nb_chunk = this._nb_last = ab_chunk.length;
					this._nb_seen += nb_chunk;
					return f_write.call(ds_transform, d_decoder.write(ab_chunk), s_encoding, fk_write);
				};

				let f_decode_write = (ab_chunk, s_encoding, fk_write) => f_write.call(ds_transform, d_decoder.write(ab_chunk), s_encoding, fk_write);

				ds_transform.write = function(z_chunk, s_encoding, fk_write) {
					// not null
					if(null !== z_chunk) {
						// chunk is string; adapt by resetting method to original
						if('string' === typeof z_chunk) {
							ds_transform.write = b_byte_tracking? f_write_track: f_write;
						}
						// chunk is buffer; adapt by setting decoder write method
						else {
							ds_transform.write = b_byte_tracking? f_decode_write_track: f_decode_write;
						}

						// use set method
						return ds_transform.write(z_chunk, s_encoding, fk_write);
					}

					// null, use parent
					return f_write.call(ds_transform, z_chunk, s_encoding, fk_write);
				};

				// byte tracking is enabled
				if(b_byte_tracking) {
					// overwrite emit_data method
					this.emit_data = this.data = this.restore_data = function() {
						let g_quad = this._dc_factory.quad(this._kt_subject, this._kt_predicate, this._kt_object, this._kt_graph);
						let nb_post = Buffer.from(this.s.slice(this.i)).length;
						let ib_post = this._nb_seen - nb_post;
						g_quad.byteRange = [this._nb_curr, ib_post];
						this._nb_curr = ib_post;
						this.transform.push(g_quad);
					};
				}
			}
		});

		// new listener added
		ds_transform.on('newListener', (s_event) => {
			// comment
			if('comment' === s_event) {
				this.emit_comments = (s_captured) => {
					let a_comments = s_captured.slice(1).replace(/\n\s+$/, '').split(/\n+\s*#/g);

					for(let s_comment of a_comments) {
						ds_transform.emit('comment', s_comment);
					}
				};
			}
		});

		// destroy
		ds_transform._destroy = (...a_args) => {
			this.destroy(...a_args);
		};

		// bind events to transform stream
		this.bind(g_config);

		// input given
		if(g_input) {
			// input is stream
			if(g_input.stream) {
				let ds_input = g_input.stream;

				// go async so caller has chance to bind event listeners
				setTimeout(() => {
					ds_input.pipe(ds_transform);
				}, 0);
			}
			// string
			else if('string' === typeof g_input.string) {
				let s_input = g_input.string;

				// go async so caller has chance to bind event listeners
				setTimeout(() => {
					ds_transform.end(s_input, 'utf8');
				}, 0);
			}
			// invalid arg
			else {
				throw new TypeError(`Invalid argument for input parameter: ${'object' === typeof g_input? JSON.stringify(g_input): g_input}`);
			}
		}
	}

	// begin parsing, keep applying until no more stack bail-outs
	safe_parse() {
		try {
			let f_sync = this._f_state();
			while('function' === typeof f_sync) {
				f_sync = f_sync.apply(this);
			}
		}
		// read error occurred
		catch(e_read) {
			// destroy self and stream
			this.destroy(e_read);

			// failure
			return false;
		}

		// okay
		return true;
	}


	emit(s_event, ...a_args) {
		this.transform.emit(s_event, ...a_args);
	}

	queue(s_event, ...a_args) {
		this._a_queue_event.push({
			event: s_event,
			args: a_args,
		});
	}

	error(s_message) {
		// bail out
		throw new Error(s_message);
	}

	// parse_error (not meant to be an event callback)
	parse_error(s_expected, b_eof=false) {
		let i = this.i;

		let i_off = Math.min(i, Math.abs(i-15));

		let s = this.s;

		return this.error(`\n\`${s.substr(i_off, i_off+90).replace(/[\n\t]/g, ' ')}\`\n`
			+` ${' '.repeat(i-i_off)}^\n`
			+`expected ${s_expected} ${b_eof? 'but encountered <<EOF>>': ''}.  failed to parse a valid token starting at ${s[i]? '"'+s[i]+'"': '<<EOF>>'}`);
	}

	info_error(s_message) {
		let i = this.i;

		let i_off = Math.min(i, Math.abs(i-15));

		let s = this.s;

		this.error(`\n\`${s.substr(i_off, i_off+90).replace(/[\n\t]/g, ' ')}\`\n`
			+` ${' '.repeat(i-i_off)}^\n`
			+s_message);
	}

	// end of file
	eof() {
		// there are events queued
		if(this._a_queue_event.length) {
			let a_queue = this._a_queue_event;

			// drain event queue
			while(a_queue.length) {
				// remove event from front of queue
				let h_event = a_queue.shift();

				// make event callback
				this[h_event.event](h_event.data);
			}
		}

		// invalid parsing state
		if(this.statement !== this._f_state) {
			// append EOF char
			this.s += '\0';

			// exit "flowing" mode
			this.n = this.s.length;

			// resume parsing; no errors
			if(this.safe_parse()) {
				// eof has occurred under safe parse
				if(null === this.s) return;

				// still invalid parsing state
				if(this.statement !== this._f_state) {
					return this.parse_error(this._f_state.name, true);
				}
			}
		}

		// there are still unparsed characters
		if(this.i < this.n) {
			// consume whitespace and comments
			let s = this.s;
			let i = this.i;
			// consume whitespace (and incidentally reset index)
			R_WS.lastIndex = i;
			R_WS.exec(s);
			i = R_WS.lastIndex;
			R_COMMENT.lastIndex = i;
			let m_comment = R_COMMENT.exec(s);

			// advance beyond comment
			if(R_COMMENT.lastIndex > i) {
				this.i = i = R_COMMENT.lastIndex;
				if(this.emit_comments) this.emit_comments(m_comment[0]);
			}

			// still unparsed characters
			if(i < this.n) {
				// not EOF
				if(!(i === this.n - 1 && '\0' === s[i])) {
					// bad input; parse error
					return this.parse_error(this._f_state.name);
				}
			}
		}

		// make buffer's alloc eligible for gc
		this.s = null;

		// transform stream
		let ds_transform = this.transform;

		// final progress update: no additional bytes were read
		ds_transform.emit('progress', 0);

		// call end event listener
		ds_transform.emit('eof', this._h_prefixes);

		// close write stream (EOF-signaling)
		ds_transform.push(null);
	}



	// bind event listeners to transform stream
	bind(g_config) {
		let ds_transform = this.transform;
		if(g_config.base) ds_transform.on('base', g_config.base);
		if(g_config.prefix) ds_transform.on('prefix', g_config.prefix);
		if(g_config.comment) ds_transform.on('comment', g_config.comment);
		if(g_config.error) ds_transform.on('error', g_config.error);
		if(g_config.read) ds_transform.once('read', g_config.read);
		if(g_config.progress) ds_transform.on('progress', g_config.progress);
		if(g_config.eof) ds_transform.once('eof', g_config.eof);
		if(g_config.end) ds_transform.once('end', g_config.end);
		if(g_config.finish) ds_transform.once('finish', g_config.finish);
		if(g_config.data) ds_transform.on('data', g_config.data);
	}

	// after a blank node subject (either property-list or colleciton)
	post_blank_subject() {
		let {s, i} = this;
		if('.' === s[i]) {
			// consume whitespace (and incidentally reset index)
			R_WS.lastIndex = i+1;
			R_WS.exec(s);
			this.i = R_WS.lastIndex;

			return this.statement();
		}
		return this.pairs();
	}



	// parse state for statement
	statement() {
		// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
// prefixed name quick

			// prepare sticky regex index
			R_PREFIXED_NAME_QUICK.lastIndex = i;
			// execute regex
			let m_pnq_subject = R_PREFIXED_NAME_QUICK.exec(s);

			// regex was a match
			if(m_pnq_subject) {
				// advance index
				this.i = R_PREFIXED_NAME_QUICK.lastIndex;
				// check valid prefix
				let s_prefix_id = m_pnq_subject[1] || '';
				// invalid prefix
				if(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix "${s_prefix_id}"`);


				// commit subject iri from resolve prefixed name
				this._kt_subject = this.prefixed_name(s_prefix_id, m_pnq_subject[2]);

				// predicate-object pairs state
				return this.pairs();

			// iriref
			}
			else {
				// prepare sticky regex index
				R_IRIREF_ESCAPELESS.lastIndex = i;
				// execute regex
				let m_iriref_e_subject = R_IRIREF_ESCAPELESS.exec(s);

				// regex was a match
				if(m_iriref_e_subject) {
					// advance index
					this.i = R_IRIREF_ESCAPELESS.lastIndex;

					// ref iri
					let s_iri = m_iriref_e_subject[1];
					// absolute iri
					if(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
						// set subject
						this._kt_subject = this.check_named_node_escapeless(s_iri);
					}
					// relative iri
					else {
						this._kt_subject = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));
					}

					// predicate-object pairs state
					return this.pairs();



				// prefixed name
				}
				else {
					// try match
					let aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);
					// stack bail out
					if(!aw_valid_this_match_prefixed_name_escapeless) return true;
					let [m_prefixed_named_e_subject, im_prefixed_named_e_subject] = aw_valid_this_match_prefixed_name_escapeless;
					if(m_prefixed_named_e_subject) {
						// advance index
						this.i = im_prefixed_named_e_subject;

						// check valid prefix
						let s_prefix_id = m_prefixed_named_e_subject[1] || '';
						// invalid prefix
						if(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix "${s_prefix_id}"`);


						// make subject key
						this._kt_subject = this.prefixed_name(s_prefix_id, m_prefixed_named_e_subject[2]);

						// predicate-object pairs state
						return this.pairs();

					// blank node label
					}
					else {
						// prepare sticky regex index
						R_BLANK_NODE_LABEL.lastIndex = i;
						// execute regex
						let m_blank_node_label_subject = R_BLANK_NODE_LABEL.exec(s);

						// regex was a match
						if(m_blank_node_label_subject) {
							// advance index
							this.i = R_BLANK_NODE_LABEL.lastIndex;
							// extract label
							let s_label = m_blank_node_label_subject[1];

							// make subject key
							this._kt_subject = this.blank_node(s_label);

							// predicate-object pairs state
							return this.pairs();

						// anonymous blank node subject
						}
						else {
							// prepare sticky regex index
							R_ANONYMOUS_BLANK_NODE.lastIndex = i;

							if(R_ANONYMOUS_BLANK_NODE.exec(s)) {
								// advance index
								this.i = R_ANONYMOUS_BLANK_NODE.lastIndex;
								// set new blank node as subject
								this._kt_subject = this.anonymous_blank_node(this.next_label());

								// goto pairs state for inside property list
								return this.pairs();

							// anonymous blank node property list subject
							}
							else {
								// prepare sticky regex index
								R_CHAR_BLANK_NODE.lastIndex = i;

								if(R_CHAR_BLANK_NODE.exec(s)) {
									// advance index
									this.i = R_CHAR_BLANK_NODE.lastIndex;
									// enter blank node
									this._kt_subject = this.anonymous_blank_node(this.next_label());

									// how to resume when we pop state
									this._a_nested.push([this._kt_subject, this._kt_predicate, 'post_blank_subject']);

									// goto pairs state for inside property list
									return this.pairs();

								// rdf collection
								}
								else {
									// prepare sticky regex index
									R_CHAR_COLLECTION.lastIndex = i;

									if(R_CHAR_COLLECTION.exec(s)) {
										// advance index
										this.i = R_CHAR_COLLECTION.lastIndex;
										// indicate that collection subject should emit an initial statement
										this._kt_subject = null;

// (don't push state, we don't have a subject yet)

										// goto collection-subject state
										return this.collection_subject();

									// prefix with interupt (e.g., a comment)
									}
									else {
										// prepare sticky regex index
										R_PREFIX_KEYWORD.lastIndex = i;
										// execute regex
										let m_prefix_keyword = R_PREFIX_KEYWORD.exec(s);

										// regex was a match
										if(m_prefix_keyword) {
											// advance index
											this.i = R_PREFIX_KEYWORD.lastIndex;
											// save whether or not to expect a full stop
											this._b_expecting_full_stop = !!m_prefix_keyword[1];

											// goto prefix state
											return this.prefix_id();

										// base with interupt (e.g., a comment)
										}
										else {
											// prepare sticky regex index
											R_BASE_KEYWORD.lastIndex = i;
											// execute regex
											let m_base_keyword = R_BASE_KEYWORD.exec(s);

											// regex was a match
											if(m_base_keyword) {
												// advance index
												this.i = R_BASE_KEYWORD.lastIndex;
												// save whether or not to expect a full stop
												this._b_expecting_full_stop = !!m_base_keyword[1];

												// goto base state
												return this.base_iri();


											// iriref
											}
											else {
												// prepare sticky regex index
												R_IRIREF.lastIndex = i;
												// execute regex
												let m_iriref_subject = R_IRIREF.exec(s);

												// regex was a match
												if(m_iriref_subject) {
													// advance index
													this.i = R_IRIREF.lastIndex;

													// ref iri
													let s_iri = m_iriref_subject[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);
													// absolute iri
													if(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
														// set subject
														this._kt_subject = this.check_named_node(s_iri);
													}
													// relative iri
													else {
														this._kt_subject = this.check_named_node(uri.resolve(this._s_base_url, s_iri));
													}

													// predicate-object pairs state
													return this.pairs();

												// prefixed name
												}
												else {
													// try match
													let aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);
													// stack bail out
													if(!aw_valid_this_match_prefixed_name) return true;
													let [m_prefixed_named_subject, im_prefixed_named_subject] = aw_valid_this_match_prefixed_name;
													if(m_prefixed_named_subject) {
														// advance index
														this.i = im_prefixed_named_subject;
														// check valid prefix
														let s_prefix_id = m_prefixed_named_subject[1] || '';
														// invalid prefix
														if(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix "${s_prefix_id}"`);


														// escape local escapes
														let s_suffix = m_prefixed_named_subject[2]
															.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)
															.replace(R_PN_LOCAL_ESCAPES, '$1');

														// make subject key
														this._kt_subject = this.prefixed_name(s_prefix_id, s_suffix);

														// predicate-object pairs state
														return this.pairs();


													// comment
													}
													else {
														// prepare sticky regex index
														R_COMMENT.lastIndex = i;
														// execute regex
														let m_comment = R_COMMENT.exec(s);

														// regex was a match
														if(m_comment) {
															// advance index
															i = R_COMMENT.lastIndex;
															if(this.emit_comments) this.emit_comments(m_comment[0]);
															continue;

			// not iriref, not prefixed name, not blank node label, not prefix id, not base
			// match counter: 11
														}
														else {
															// break loop to retry on next chunk if eos
															break;
														}
													} // brace #11
												} // brace #10
											} // brace #9
										} // brace #8
									} // brace #7
								} // brace #6
							} // brace #5
						} // brace #4
					} // brace #3
				} // brace #2
			} // brace #1
		}

				// ran out of characters
				// update index value
		this.i = i;

		// not yet eos
		if(i < this.n) {
			// expected token was not found
			if(0 === i) {
				// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('statement');
				}
			}
		}

		// save state before pausing
		this._f_state = this.statement;

		// store what is unparsed
		this.pre = s.slice(i);

		// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}



	// parse state for pairs
	pairs() {
		// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
// benchmarks indicate: regex for end of blank node property list faster than ch


// iriref

			// prepare sticky regex index
			R_IRIREF_ESCAPELESS.lastIndex = i;
			// execute regex
			let m_iriref_e_predicate = R_IRIREF_ESCAPELESS.exec(s);

			// regex was a match
			if(m_iriref_e_predicate) {
				// advance index
				this.i = R_IRIREF_ESCAPELESS.lastIndex;

				// ref iri
				let s_iri = m_iriref_e_predicate[1];
				// absolute iri
				if(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
					// set predicate
					this._kt_predicate = this.check_named_node_escapeless(s_iri);
				}
				// relative iri
				else {
					this._kt_predicate = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));
				}

				// object-list state
				return this.object_list();

			// prefixed name
			}
			else {
				// try match
				let aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);
				// stack bail out
				if(!aw_valid_this_match_prefixed_name_escapeless) return true;
				let [m_prefixed_named_e_predicate, im_prefixed_named_e_predicate] = aw_valid_this_match_prefixed_name_escapeless;
				if(m_prefixed_named_e_predicate) {
					// advance index
					this.i = im_prefixed_named_e_predicate;
					// check valid prefix
					let s_prefix_id = m_prefixed_named_e_predicate[1] || '';
					// invalid prefix
					if(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix "${s_prefix_id}"`);


					// make predicate key
					this._kt_predicate = this.prefixed_name(s_prefix_id, m_prefixed_named_e_predicate[2]);

					// object-list state
					return this.object_list();

				// 'a'
				}
				else {
					// prepare sticky regex index
					R_A.lastIndex = i;

					if(R_A.exec(s)) {
						// advance index
						this.i = R_A.lastIndex;
						// make predicate key
						this._kt_predicate = this._kt_rdf_type;

						// object-list state
						return this.object_list();

					// ']' end of blank node property list
					}
					else {
						// prepare sticky regex index
						R_CHAR_KET.lastIndex = i;

						if(R_CHAR_KET.exec(s)) {
							// advance index
							this.i = R_CHAR_KET.lastIndex;
							let s_resume_state;
							[this._kt_subject, this._kt_predicate, s_resume_state] = this._a_nested.pop();
							return this[s_resume_state]();

						// iriref
						}
						else {
							// prepare sticky regex index
							R_IRIREF.lastIndex = i;
							// execute regex
							let m_iriref_predicate = R_IRIREF.exec(s);

							// regex was a match
							if(m_iriref_predicate) {
								// advance index
								this.i = R_IRIREF.lastIndex;

								// ref iri
								let s_iri = m_iriref_predicate[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);
								// absolute iri
								if(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
									// set predicate
									this._kt_predicate = this.check_named_node(s_iri);
								}
								// relative iri
								else {
									this._kt_predicate = this.check_named_node(uri.resolve(this._s_base_url, s_iri));
								}

								// object-list state
								return this.object_list();

							// prefixed name
							}
							else {
								// try match
								let aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);
								// stack bail out
								if(!aw_valid_this_match_prefixed_name) return true;
								let [m_prefixed_named_predicate, im_prefixed_named_predicate] = aw_valid_this_match_prefixed_name;
								if(m_prefixed_named_predicate) {
									// advance index
									this.i = im_prefixed_named_predicate;
									// check valid prefix
									let s_prefix_id = m_prefixed_named_predicate[1] || '';
									// invalid prefix
									if(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix "${s_prefix_id}"`);


									// escape local escapes
									let s_suffix = m_prefixed_named_predicate[2]
										.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)
										.replace(R_PN_LOCAL_ESCAPES, '$1');

									// make predicate key
									this._kt_predicate = this.prefixed_name(s_prefix_id, s_suffix);

									// object-list state
									return this.object_list();
								}
								else {
									// prepare sticky regex index
									R_COMMENT.lastIndex = i;
									// execute regex
									let m_comment = R_COMMENT.exec(s);

									// regex was a match
									if(m_comment) {
										// advance index
										i = R_COMMENT.lastIndex;
										if(this.emit_comments) this.emit_comments(m_comment[0]);
										continue;

			// not iriref, not prefixed name, not 'a'
			// match counter: 6
									}
									else {
										// break loop to retry on next chunk if eos
										break;
									}
								} // brace #6
							} // brace #5
						} // brace #4
					} // brace #3
				} // brace #2
			} // brace #1
		}

				// ran out of characters
				// update index value
		this.i = i;

		// not yet eos
		if(i < this.n) {
			// expected token was not found
			if(0 === i) {
				// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('pairs');
				}
			}
		}

		// save state before pausing
		this._f_state = this.pairs;

		// store what is unparsed
		this.pre = s.slice(i);

		// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}



	// parse state for object_list
	object_list() {
		// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
			// ref char
			let x = s[i];

			// string literal * double
			if('"' === x) {
				// enough chars to deduce type
				if((i+2) < n) {
					// long type
					if('"' === s[i+1] && '"' === s[i+2]) {
						// advance index beyond token
						this.i = i + 3;

						// read contents
						return this.string_literal_long_double();
					}
					// not long type
					else {
						// advance index beyond token
						this.i = i + 1;

						// read contents
						return this.string_literal_short_double();
					}
				}
				// enough chars to eliminate long type
				else if((i+1) < n && '"' !== s[i+1]) {
					// advance index beyond token
					this.i = i + 1;

					// read contents
					return this.string_literal_short_double();
				}
				// not enough chars to deduce type; retry next chunk
				else {
					break;
				}

			// prefixed name quick
			}
			else {
				// prepare sticky regex index
				R_PREFIXED_NAME_QUICK.lastIndex = i;
				// execute regex
				let m_pnq_object = R_PREFIXED_NAME_QUICK.exec(s);

				// regex was a match
				if(m_pnq_object) {
					// advance index
					this.i = R_PREFIXED_NAME_QUICK.lastIndex;
					// check valid prefix
					let s_prefix_id = m_pnq_object[1] || '';
					// invalid prefix
					if(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix "${s_prefix_id}"`);


					// commit object iri from resolve prefixed name
					this._kt_object = this.prefixed_name(s_prefix_id, m_pnq_object[2]);

				// iriref
				}
				else {
					// prepare sticky regex index
					R_IRIREF_ESCAPELESS.lastIndex = i;
					// execute regex
					let m_iriref_e_object = R_IRIREF_ESCAPELESS.exec(s);

					// regex was a match
					if(m_iriref_e_object) {
						// advance index
						this.i = R_IRIREF_ESCAPELESS.lastIndex;

						// ref iri
						let s_iri = m_iriref_e_object[1];
						// absolute iri
						if(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
							// set object
							this._kt_object = this.check_named_node_escapeless(s_iri);
						}
						// relative iri
						else {
							this._kt_object = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));
						}

					// prefixed name
					}
					else {
						// try match
						let aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);
						// stack bail out
						if(!aw_valid_this_match_prefixed_name_escapeless) return true;
						let [m_prefixed_named_e_object, im_prefixed_named_e_object] = aw_valid_this_match_prefixed_name_escapeless;
						if(m_prefixed_named_e_object) {
							// advance index
							this.i = im_prefixed_named_e_object;
							// check valid prefix
							let s_prefix_id = m_prefixed_named_e_object[1] || '';
							// invalid prefix
							if(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix "${s_prefix_id}"`);


							// commit object iri from resolve prefixed name
							this._kt_object = this.prefixed_name(s_prefix_id, m_prefixed_named_e_object[2]);

						// string literal * single
						}
						else 	if('\'' === x) {
							// enough chars to deduce type
							if((i+2) < n) {
								// long type
								if("'" === s[i+1] && "'" === s[i+2]) {
									// advance index beyond token
									this.i = i + 3;

									// read contents
									return this.string_literal_long_single();
								}
								// not long type
								else {
									// advance index beyond token
									this.i = i + 1;

									// read contents
									return this.string_literal_short_single();
								}
							}
							// enough chars to eliminate long type
							else if((i+1) < n && "'" !== s[i+1]) {
								// advance index beyond token
								this.i = i + 1;

								// read contents
								return this.string_literal_short_single();
							}
							// not enough chars to deduce type; retry next chunk
							else {
								break;
							}

						// numeric literal
						}
						else {
							// prepare sticky regex index
							R_NUMERIC_LITERAL.lastIndex = i;
							// execute regex
							let m_numeric_literal = R_NUMERIC_LITERAL.exec(s);

							// regex was a match
							if(m_numeric_literal) {
								// advance index
								this.i = R_NUMERIC_LITERAL.lastIndex;
								// it has exponent term, xsd:double
								if(m_numeric_literal[4]) {
									this._kt_object = this._dc_factory.double(m_numeric_literal[1]);
								}
								// contains decimal point, xsd:decimal
								else if(m_numeric_literal[2] || m_numeric_literal[3]) {
									this._kt_object = this._dc_factory.decimal(m_numeric_literal[1]);
								}
								// otherwise, it is an integer
								else {
									this._kt_object = this._dc_factory.integer(m_numeric_literal[1]);
								}


							// boolean literal
							}
							else {
								// prepare sticky regex index
								R_BOOLEAN_LITERAL.lastIndex = i;
								// execute regex
								let m_boolean_literal = R_BOOLEAN_LITERAL.exec(s);

								// regex was a match
								if(m_boolean_literal) {
									// advance index
									this.i = R_BOOLEAN_LITERAL.lastIndex;
									// make literal
									this._kt_object = this._dc_factory.boolean(!!m_boolean_literal[1]);


								// blank node property list
								}
								else 	if('[' === x) {
				// advance index to next token
				// consume whitespace (and incidentally reset index)
									R_WS.lastIndex = i+1;
									R_WS.exec(s);
									this.i = R_WS.lastIndex;

									// make object
									let kt_blank_node = this._kt_object = this.anonymous_blank_node(this.next_label());

									// emit statement event
									this.data();


									// push state to stack
									this._a_nested.push([this._kt_subject, this._kt_predicate, 'post_object']);

									// set new subject
									this._kt_subject = kt_blank_node;

									// goto parsing pairs state
									return this.pairs();

								// labeled blank node
								}
								else {
									// prepare sticky regex index
									R_BLANK_NODE_LABEL_TERMINAL.lastIndex = i;
									// execute regex
									let m_blank_node_label_object = R_BLANK_NODE_LABEL_TERMINAL.exec(s);

									// regex was a match
									if(m_blank_node_label_object) {
										// advance index
										this.i = R_BLANK_NODE_LABEL_TERMINAL.lastIndex;
										// ref blank node label
										let s_label = m_blank_node_label_object[1];

										// make object
										this._kt_object = this.blank_node(s_label);

									// collection
									}
									else 	if('(' === x) {
				// advance index to next token
				// consume whitespace (and incidentally reset index)
										R_WS.lastIndex = i+1;
										R_WS.exec(s);
										this.i = R_WS.lastIndex;

										// state to resume after collection ends
										this._a_nested.push([this._kt_subject, this._kt_predicate, 'post_object']);

										// goto collection-object state
										return this.collection_object();

									// iriref
									}
									else {
										// prepare sticky regex index
										R_IRIREF.lastIndex = i;
										// execute regex
										let m_iriref_object = R_IRIREF.exec(s);

										// regex was a match
										if(m_iriref_object) {
											// advance index
											this.i = R_IRIREF.lastIndex;

											// ref iri
											let s_iri = m_iriref_object[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);
											// absolute iri
											if(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
												// set object
												this._kt_object = this.check_named_node(s_iri);
											}
											// relative iri
											else {
												this._kt_object = this.check_named_node(uri.resolve(this._s_base_url, s_iri));
											}

										// prefixed name
										}
										else {
											// try match
											let aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);
											// stack bail out
											if(!aw_valid_this_match_prefixed_name) return true;
											let [m_prefixed_named_object, im_prefixed_named_object] = aw_valid_this_match_prefixed_name;
											if(m_prefixed_named_object) {
												// advance index
												this.i = im_prefixed_named_object;
												// check valid prefix
												let s_prefix_id = m_prefixed_named_object[1] || '';
												// invalid prefix
												if(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix "${s_prefix_id}"`);


												// escape local escapes
												let s_suffix = m_prefixed_named_object[2]
													.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)
													.replace(R_PN_LOCAL_ESCAPES, '$1');

												// commit object iri from resolve prefixed name
												this._kt_object = this.prefixed_name(s_prefix_id, s_suffix);
											}
											else {
												// prepare sticky regex index
												R_COMMENT.lastIndex = i;
												// execute regex
												let m_comment = R_COMMENT.exec(s);

												// regex was a match
												if(m_comment) {
													// advance index
													i = R_COMMENT.lastIndex;
													if(this.emit_comments) this.emit_comments(m_comment[0]);
													continue;

			// not iriref, not prefixed name, not string literal, not numeric literal, not boolean literal, not blank node property list, not collection
			// match counter: 9
												}
												else {
													// break loop to retry on next chunk if eos
													break;
												}
											} // brace #9
										} // brace #8
									} // brace #7
								} // brace #6
							} // brace #5
						} // brace #4
					} // brace #3
				} // brace #2
			} // brace #1


			// fall through for cases that did not change state on their own
			// at this point, a new statement has been parsed
			this.data();


			// goto next parsing state; bail out of stack
			return this.after_end_of_statement;
		}

				// ran out of characters
				// update index value
		this.i = i;

		// not yet eos
		if(i < this.n) {
			// expected token was not found
			if(0 === i) {
				// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('object_list');
				}
			}
		}

		// save state before pausing
		this._f_state = this.object_list;

		// store what is unparsed
		this.pre = s.slice(i);

		// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}



	// parse state for string_literal_short_double
	string_literal_short_double() {
		// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		string_literal_short_double: while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
// something breaks string in this chunk

			// prepare sticky regex index
			R_STRLIT_SHORT_DOUBLE_BREAK.lastIndex = i;
			// execute regex
			let m_break = R_STRLIT_SHORT_DOUBLE_BREAK.exec(s);

			// regex was a match
			if(m_break) {
				// advance index
				this.i = R_STRLIT_SHORT_DOUBLE_BREAK.lastIndex;
				// index of break
				let i_break = m_break.index;

				// add to contents
				this._s_literal += s.slice(i, i_break);

				// depending on char
				switch(s[i_break]) {
					// terminator
					case '"': {
					// advance index to next token beyond delimiter
					// consume whitespace (and incidentally reset index)
						R_WS.lastIndex = i_break + 1;
						R_WS.exec(s);
						this.i = R_WS.lastIndex;

						// resume eating whitespace at start of next chunk
						this._b_trim_start = true;

						// consume rest
						return this.datatype_or_langtag();
					}

					// escape
					case '\\': {
						// try to find end
						R_STRLIT_SHORT_DOUBLE_TERM.lastIndex = i_break;
						let m_term = R_STRLIT_SHORT_DOUBLE_TERM.exec(s);

						// end is in this chunk
						if(m_term) {
							// index of terminator
							let i_term = m_term.index;

							// extract dirty potion
							let s_dirty = s.slice(i_break, i_term);

							// clean and save
							this._s_literal += unescape_literal_short_hard(s_dirty);

							// advance index beyond terminator
							this.i = i_term + m_term[0].length;

							// resume eating whitespace at start of next chunk
							this._b_trim_start = true;

							// consume rest
							return this.datatype_or_langtag();
						}
						// end is not in this chunk
						else {
							// extract whole portion
							let s_dirty = s.slice(i_break);

							// unescape to clean part
							let [s_clean, s_incomplete] = unescape_literal_short_soft(s_dirty);

							// save
							this._s_literal += s_clean;

							// set unparsed index
							i = n - s_incomplete.length;

							// reached eos; pause normally
							break string_literal_short_double;
						}
					}

					// invalid '\n'
					case '\n': {
						return this.info_error(`expected string_literal_short_double but invalid line feed character '\\n' (newline) within contents. failed to parse a valid token`);
					}

					// invalid '\r'
					case '\r': {
						return this.info_error(`expected string_literal_short_double but invalid form feed character '\\r' (carriage return) within contents. failed to parse a valid token`);
					}

					// invalid
					default: {
						console.assert(`Unhandle invalid character ${JSON.stringify(s[i_break])} case for string_literal_short_double`);
					}
				}

		// no terminator and nothing to escape
		// match counter: 0
			}
			else {
				// save
				this._s_literal += i? s.slice(i): s;

				// set unparsed index
				i = n;

				// reached eos; pause normally
				break;
			}
		}

		// do not eat whitespace at start of next chunk
		this._b_trim_start = false;

	// ran out of characters
	// update index value
		this.i = i;

		// not yet eos
		if(i < this.n) {
			// expected token was not found
			if(0 === i) {
				// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('string_literal_short_double');
				}
			}
		}

		// save state before pausing
		this._f_state = this.string_literal_short_double;

		// store what is unparsed
		this.pre = s.slice(i);

		// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}



	// parse state for string_literal_short_single
	string_literal_short_single() {
		// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		string_literal_short_single: while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
// something breaks string in this chunk

			// prepare sticky regex index
			R_STRLIT_SHORT_SINGLE_BREAK.lastIndex = i;
			// execute regex
			let m_break = R_STRLIT_SHORT_SINGLE_BREAK.exec(s);

			// regex was a match
			if(m_break) {
				// advance index
				this.i = R_STRLIT_SHORT_SINGLE_BREAK.lastIndex;
				// index of break
				let i_break = m_break.index;

				// add to contents
				this._s_literal += s.slice(i, i_break);

				// depending on char
				switch(s[i_break]) {
					// terminator
					case "'": {
					// advance index to next token beyond delimiter
					// consume whitespace (and incidentally reset index)
						R_WS.lastIndex = i_break + 1;
						R_WS.exec(s);
						this.i = R_WS.lastIndex;

						// resume eating whitespace at start of next chunk
						this._b_trim_start = true;

						// consume rest
						return this.datatype_or_langtag();
					}

					// escape
					case '\\': {
						// try to find end
						R_STRLIT_SHORT_SINGLE_TERM.lastIndex = i_break;
						let m_term = R_STRLIT_SHORT_SINGLE_TERM.exec(s);

						// end is in this chunk
						if(m_term) {
							// index of terminator
							let i_term = m_term.index;

							// extract dirty potion
							let s_dirty = s.slice(i_break, i_term);

							// clean and save
							this._s_literal += unescape_literal_short_hard(s_dirty);

							// advance index beyond terminator
							this.i = i_term + m_term[0].length;

							// resume eating whitespace at start of next chunk
							this._b_trim_start = true;

							// consume rest
							return this.datatype_or_langtag();
						}
						// end is not in this chunk
						else {
							// extract whole portion
							let s_dirty = s.slice(i_break);

							// unescape to clean part
							let [s_clean, s_incomplete] = unescape_literal_short_soft(s_dirty);

							// save
							this._s_literal += s_clean;

							// set unparsed index
							i = n - s_incomplete.length;

							// reached eos; pause normally
							break string_literal_short_single;
						}
					}

					// invalid '\n'
					case '\n': {
						return this.info_error(`expected string_literal_short_single but invalid line feed character '\\n' (newline) within contents. failed to parse a valid token`);
					}

					// invalid '\r'
					case '\r': {
						return this.info_error(`expected string_literal_short_single but invalid form feed character '\\r' (carriage return) within contents. failed to parse a valid token`);
					}

					// invalid
					default: {
						console.assert(`Unhandle invalid character ${JSON.stringify(s[i_break])} case for string_literal_short_single`);
					}
				}

		// no terminator and nothing to escape
		// match counter: 0
			}
			else {
				// save
				this._s_literal += i? s.slice(i): s;

				// set unparsed index
				i = n;

				// reached eos; pause normally
				break;
			}
		}

		// do not eat whitespace at start of next chunk
		this._b_trim_start = false;

	// ran out of characters
	// update index value
		this.i = i;

		// not yet eos
		if(i < this.n) {
			// expected token was not found
			if(0 === i) {
				// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('string_literal_short_single');
				}
			}
		}

		// save state before pausing
		this._f_state = this.string_literal_short_single;

		// store what is unparsed
		this.pre = s.slice(i);

		// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}



	// parse state for string_literal_long_double
	string_literal_long_double() {
		// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		string_literal_long_double: while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
// something breaks string in this chunk

			// prepare sticky regex index
			R_STRLIT_LONG_DOUBLE_BREAK.lastIndex = i;
			// execute regex
			let m_break = R_STRLIT_LONG_DOUBLE_BREAK.exec(s);

			// regex was a match
			if(m_break) {
				// advance index
				this.i = R_STRLIT_LONG_DOUBLE_BREAK.lastIndex;
				// index of break
				let i_break = m_break.index;

				// add to contents
				this._s_literal += s.slice(i, i_break);

				// depending on char
				switch(s[i_break]) {
					// terminator
					case '"': {
					// advance index to next token beyond delimiter
					// consume whitespace (and incidentally reset index)
						R_WS.lastIndex = i_break + 3;
						R_WS.exec(s);
						this.i = R_WS.lastIndex;

						// resume eating whitespace at start of next chunk
						this._b_trim_start = true;

						// consume rest
						return this.datatype_or_langtag();
					}

					// escape
					case '\\': {
						// try to find end
						R_STRLIT_LONG_DOUBLE_TERM.lastIndex = i_break;
						let m_term = R_STRLIT_LONG_DOUBLE_TERM.exec(s);

						// end is in this chunk
						if(m_term) {
							// index of terminator
							let i_term = m_term.index;

							// extract dirty potion
							let s_dirty = s.slice(i_break, i_term);

							// clean and save
							this._s_literal += unescape_literal_long_hard(s_dirty);

							// advance index beyond terminator
							this.i = i_term + m_term[0].length;

							// resume eating whitespace at start of next chunk
							this._b_trim_start = true;

							// consume rest
							return this.datatype_or_langtag();
						}
						// end is not in this chunk
						else {
							// extract whole portion
							let s_dirty = s.slice(i_break);

							// unescape to clean part
							let [s_clean, s_incomplete] = unescape_literal_long_soft(s_dirty);

							// save
							this._s_literal += s_clean;

							// set unparsed index
							i = n - s_incomplete.length;

							// reached eos; pause normally
							break string_literal_long_double;
						}
					}

					// invalid
					default: {
						console.assert(`Unhandle invalid character ${JSON.stringify(s[i_break])} case for string_literal_long_double`);
					}
				}

		// no terminator and nothing to escape
		// match counter: 0
			}
			else {
				// could be unfinished terminator
				R_STRLIT_LONG_DOUBLE_UNFINISHED_TERM.lastIndex = i;
				let m_unfinished = R_STRLIT_LONG_DOUBLE_UNFINISHED_TERM.exec(s);

				// unfinished terminator
				if(m_unfinished) {
					// save valid portion
					this._s_literal += s.slice(i, m_unfinished.index);

					// set unparsed index
					i = m_unfinished.index;
				}
				// not unfinished
				else {
					// save
					this._s_literal += i? s.slice(i): s;

					// set unparsed index
					i = n;
				}

				// reached eos; pause normally
				break;
			}
		}

		// do not eat whitespace at start of next chunk
		this._b_trim_start = false;

	// ran out of characters
	// update index value
		this.i = i;

		// not yet eos
		if(i < this.n) {
			// expected token was not found
			if(0 === i) {
				// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('string_literal_long_double');
				}
			}
		}

		// save state before pausing
		this._f_state = this.string_literal_long_double;

		// store what is unparsed
		this.pre = s.slice(i);

		// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}



	// parse state for string_literal_long_single
	string_literal_long_single() {
		// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		string_literal_long_single: while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
// something breaks string in this chunk

			// prepare sticky regex index
			R_STRLIT_LONG_SINGLE_BREAK.lastIndex = i;
			// execute regex
			let m_break = R_STRLIT_LONG_SINGLE_BREAK.exec(s);

			// regex was a match
			if(m_break) {
				// advance index
				this.i = R_STRLIT_LONG_SINGLE_BREAK.lastIndex;
				// index of break
				let i_break = m_break.index;

				// add to contents
				this._s_literal += s.slice(i, i_break);

				// depending on char
				switch(s[i_break]) {
					// terminator
					case "'": {
					// advance index to next token beyond delimiter
					// consume whitespace (and incidentally reset index)
						R_WS.lastIndex = i_break + 3;
						R_WS.exec(s);
						this.i = R_WS.lastIndex;

						// resume eating whitespace at start of next chunk
						this._b_trim_start = true;

						// consume rest
						return this.datatype_or_langtag();
					}

					// escape
					case '\\': {
						// try to find end
						R_STRLIT_LONG_SINGLE_TERM.lastIndex = i_break;
						let m_term = R_STRLIT_LONG_SINGLE_TERM.exec(s);

						// end is in this chunk
						if(m_term) {
							// index of terminator
							let i_term = m_term.index;

							// extract dirty potion
							let s_dirty = s.slice(i_break, i_term);

							// clean and save
							this._s_literal += unescape_literal_long_hard(s_dirty);

							// advance index beyond terminator
							this.i = i_term + m_term[0].length;

							// resume eating whitespace at start of next chunk
							this._b_trim_start = true;

							// consume rest
							return this.datatype_or_langtag();
						}
						// end is not in this chunk
						else {
							// extract whole portion
							let s_dirty = s.slice(i_break);

							// unescape to clean part
							let [s_clean, s_incomplete] = unescape_literal_long_soft(s_dirty);

							// save
							this._s_literal += s_clean;

							// set unparsed index
							i = n - s_incomplete.length;

							// reached eos; pause normally
							break string_literal_long_single;
						}
					}

					// invalid
					default: {
						console.assert(`Unhandle invalid character ${JSON.stringify(s[i_break])} case for string_literal_long_single`);
					}
				}

		// no terminator and nothing to escape
		// match counter: 0
			}
			else {
				// could be unfinished terminator
				R_STRLIT_LONG_SINGLE_UNFINISHED_TERM.lastIndex = i;
				let m_unfinished = R_STRLIT_LONG_SINGLE_UNFINISHED_TERM.exec(s);

				// unfinished terminator
				if(m_unfinished) {
					// save valid portion
					this._s_literal += s.slice(i, m_unfinished.index);

					// set unparsed index
					i = m_unfinished.index;
				}
				// not unfinished
				else {
					// save
					this._s_literal += i? s.slice(i): s;

					// set unparsed index
					i = n;
				}

				// reached eos; pause normally
				break;
			}
		}

		// do not eat whitespace at start of next chunk
		this._b_trim_start = false;

	// ran out of characters
	// update index value
		this.i = i;

		// not yet eos
		if(i < this.n) {
			// expected token was not found
			if(0 === i) {
				// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('string_literal_long_single');
				}
			}
		}

		// save state before pausing
		this._f_state = this.string_literal_long_single;

		// store what is unparsed
		this.pre = s.slice(i);

		// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}



	// parse state for string_literal
	string_literal() {
		// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
			// ref character
			let x = s[i];

			// string literal * double
			if('"' === x) {
				// enough chars to deduce type
				if((i+2) < n) {
					// long type
					if('"' === s[i+1] && '"' === s[i+2]) {
						// advance index beyond token
						this.i = i + 3;

						// read contents
						return this.string_literal_long_double();
					}
					// not long type
					else {
						// advance index beyond token
						this.i = i + 1;

						// read contents
						return this.string_literal_short_double();
					}
				}
				// enough chars to eliminate long type
				else if((i+1) < n && '"' !== s[i+1]) {
					// advance index beyond token
					this.i = i + 1;

					// read contents
					return this.string_literal_short_double();
				}
				// not enough chars to deduce type; retry next chunk
				else {
					break;
				}

			// string literal * single
			}
			else 	if('\'' === x) {
				// enough chars to deduce type
				if((i+2) < n) {
					// long type
					if("'" === s[i+1] && "'" === s[i+2]) {
						// advance index beyond token
						this.i = i + 3;

						// read contents
						return this.string_literal_long_single();
					}
					// not long type
					else {
						// advance index beyond token
						this.i = i + 1;

						// read contents
						return this.string_literal_short_single();
					}
				}
				// enough chars to eliminate long type
				else if((i+1) < n && "'" !== s[i+1]) {
					// advance index beyond token
					this.i = i + 1;

					// read contents
					return this.string_literal_short_single();
				}
				// not enough chars to deduce type; retry next chunk
				else {
					break;
				}

			// not string literal long single quote, not string literal single quote
			// match counter: 0
			}
			else {
				// break loop to retry on next chunk if eos
				break;
			}
		}

				// ran out of characters
				// update index value
		this.i = i;

		// not yet eos
		if(i < this.n) {
			// expected token was not found
			if(0 === i) {
				// we've exceeded the maximum token length
				if(this.n > this.max_string_length) {
					return this.parse_error('string_literal');
				}
			}
		}

		// save state before pausing
		this._f_state = this.string_literal;

		// store what is unparsed
		this.pre = s.slice(i);

		// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}



	// parse state for datatype_or_langtag
	datatype_or_langtag() {
		// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
			// ref character
			let x = s[i];

			// next token indicates datatype or langtag
			if('^' === x || '@' === x) {
// '^^' datatype

				// prepare sticky regex index
				R_DOUBLE_CARET.lastIndex = i;

				if(R_DOUBLE_CARET.exec(s)) {
					// advance index
					this.i = R_DOUBLE_CARET.lastIndex;
					return this.datatype();

				// '@' language tag
				}
				else {
					// prepare sticky regex index
					R_LANGTAG.lastIndex = i;
					// execute regex
					let m_langtag = R_LANGTAG.exec(s);

					// regex was a match
					if(m_langtag) {
						// advance index
						this.i = R_LANGTAG.lastIndex;
						this._kt_object = this._dc_factory.languagedLiteral(this._s_literal, m_langtag[1]);

						// reset literal
						this._s_literal = '';

				// next token definitely datatype or langtag, we are just being interrupted by eos
				// match counter: 1
					}
					else {
						// break loop to retry on next chunk if eos
						break;
					}
				} // brace #1
			}
			else {
				// prepare sticky regex index
				R_COMMENT.lastIndex = i;
				// execute regex
				let m_comment = R_COMMENT.exec(s);

				// regex was a match
				if(m_comment) {
					// advance index
					i = R_COMMENT.lastIndex;
					if(this.emit_comments) this.emit_comments(m_comment[0]);
					continue;

				// match counter: 1
				}
				else {
					this._kt_object = this._dc_factory.simpleLiteral(this._s_literal);

					// reset literal
					this._s_literal = '';

				// not datatype, not language tag => that's okay! those are optional
				}
			} // brace #1


			// goto end of statement state
			// at this point, a new statement has been parsed
			this.data();


			// goto next parsing state; bail out of stack
			return this.after_end_of_statement;
		}

				// ran out of characters
				// update index value
		this.i = i;

		// not yet eos
		if(i < this.n) {
			// expected token was not found
			if(0 === i) {
				// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('datatype_or_langtag');
				}
			}
		}

		// save state before pausing
		this._f_state = this.datatype_or_langtag;

		// store what is unparsed
		this.pre = s.slice(i);

		// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}



	// parse state for datatype
	datatype() {
		// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
			let kt_datatype = null;

// prefixed name quick

			// prepare sticky regex index
			R_PREFIXED_NAME_QUICK.lastIndex = i;
			// execute regex
			let m_pnq_datatype = R_PREFIXED_NAME_QUICK.exec(s);

			// regex was a match
			if(m_pnq_datatype) {
				// advance index
				this.i = R_PREFIXED_NAME_QUICK.lastIndex;
				// check valid prefix
				let s_prefix_id = m_pnq_datatype[1] || '';
				// invalid prefix
				if(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix "${s_prefix_id}"`);


				// commit object iri from resolve prefixed name
				kt_datatype = this.prefixed_name(s_prefix_id, m_pnq_datatype[2]);

			// iriref
			}
			else {
				// prepare sticky regex index
				R_IRIREF_ESCAPELESS.lastIndex = i;
				// execute regex
				let m_iriref_e_datatype = R_IRIREF_ESCAPELESS.exec(s);

				// regex was a match
				if(m_iriref_e_datatype) {
					// advance index
					this.i = R_IRIREF_ESCAPELESS.lastIndex;
					let p_datatype;

					// ref iri
					let s_iri = m_iriref_e_datatype[1];
					// absolute iri
					if(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
						// set p_datatype
						p_datatype = s_iri;
					}
					// relative iri
					else {
						p_datatype = uri.resolve(this._s_base_url, s_iri);
					}

					kt_datatype = this.check_named_node_escapeless(p_datatype);

				// prefixed name
				}
				else {
					// try match
					let aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);
					// stack bail out
					if(!aw_valid_this_match_prefixed_name_escapeless) return true;
					let [m_prefixed_named_e_datatype, im_prefixed_named_e_datatype] = aw_valid_this_match_prefixed_name_escapeless;
					if(m_prefixed_named_e_datatype) {
						// advance index
						this.i = im_prefixed_named_e_datatype;
						// check valid prefix
						let s_prefix_id = m_prefixed_named_e_datatype[1] || '';
						// invalid prefix
						if(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix "${s_prefix_id}"`);


						kt_datatype = this.prefixed_name(s_prefix_id, m_prefixed_named_e_datatype[2]);

					// iriref
					}
					else {
						// prepare sticky regex index
						R_IRIREF.lastIndex = i;
						// execute regex
						let m_iriref_datatype = R_IRIREF.exec(s);

						// regex was a match
						if(m_iriref_datatype) {
							// advance index
							this.i = R_IRIREF.lastIndex;
							let p_datatype;

							// ref iri
							let s_iri = m_iriref_e_datatype[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);
							// absolute iri
							if(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
								// set p_datatype
								p_datatype = s_iri;
							}
							// relative iri
							else {
								p_datatype = uri.resolve(this._s_base_url, s_iri);
							}

							kt_datatype = this.check_named_node(p_datatype);

						// prefixed name
						}
						else {
							// try match
							let aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);
							// stack bail out
							if(!aw_valid_this_match_prefixed_name) return true;
							let [m_prefixed_named_datatype, im_prefixed_named_datatype] = aw_valid_this_match_prefixed_name;
							if(m_prefixed_named_datatype) {
								// advance index
								this.i = im_prefixed_named_datatype;
								// check valid prefix
								let s_prefix_id = m_prefixed_named_datatype[1] || '';
								// invalid prefix
								if(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix "${s_prefix_id}"`);


								// escape local escapes
								let s_suffix = m_prefixed_named_datatype[2]
									.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)
									.replace(R_PN_LOCAL_ESCAPES, '$1');

								// set literal datatype
								kt_datatype = this.prefixed_name(s_prefix_id, s_suffix);

			// not iriref, not prefixed name
			// match counter: 4
							}
							else {
								// break loop to retry on next chunk if eos
								break;
							}
						} // brace #4
					} // brace #3
				} // brace #2
			} // brace #1


			this._kt_object = this._dc_factory.datatypedLiteral(this._s_literal, kt_datatype);

			// reset literal
			this._s_literal = '';

			// goto end of statement state
			// at this point, a new statement has been parsed
			this.data();


			// goto next parsing state; bail out of stack
			return this.after_end_of_statement;
		}

				// ran out of characters
				// update index value
		this.i = i;

		// not yet eos
		if(i < this.n) {
			// expected token was not found
			if(0 === i) {
				// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('datatype');
				}
			}
		}

		// save state before pausing
		this._f_state = this.datatype;

		// store what is unparsed
		this.pre = s.slice(i);

		// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}



	// parse state for post_object
	post_object() {
		// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
			let i_reset = i;

			// benchmarks confirm: character ref faster than regexes in this context
			let x = s[i];

			// advance index to next token beyond delimiter
			// consume whitespace (and incidentally reset index)
			R_WS.lastIndex = i+1;
			R_WS.exec(s);
			this.i = R_WS.lastIndex;

			// ',' more objects
			if(',' === x) {
				return this.object_list();

			// ';' more predicate-object pairs
			}
			else 	if(';' === x) {
				for(;;) {
					// next token is end of outer section
					let s_peek = s[this.i];
					if('.' === s_peek || ']' === s_peek || ';' === s_peek) {
						// goto post_object state
						return this.post_object();
					}
					// comment
					else if('#' === s_peek) {
						// comment
						i = this.i;

						// prepare sticky regex index
						R_COMMENT.lastIndex = i;
						// execute regex
						let m_comment = R_COMMENT.exec(s);

						// regex was a match
						if(m_comment) {
							// advance index
							this.i = R_COMMENT.lastIndex;
							if(this.emit_comments) this.emit_comments(m_comment[0]);
							// retry
							continue;
						}


						// no eol to close comment (yet)
						else {
							// already consumed
							break;
						}
					}
					// eos
					else if(this.i === n) {
						break;
					}
					// something else
					else {
						return this.pairs();
					}
				}

				// rather than pushing a dedicated state, just try again next chunk
				i = i_reset;
				break;

			// '.' end of statement
			}
			else 	if('.' === x) {
				// assert not nested
				if(this._a_nested.length) {
					// reset index to that character
					this.i = i;

					// emit parse error
					return this.parse_error('end_of_property_list');
				}
				return this.statement();

			// ']' end of property-object pairs
			}
			else 	if(']' === x) {
				let s_resume_state;
				[this._kt_subject, this._kt_predicate, s_resume_state] = this._a_nested.pop();
				return this[s_resume_state]();

			// ')' end of collection
			}
			else 	if(')' === x) {
				// should not be here
				return Reader$syntax_error(this, i, 'post_object', 'but encountered end of collection');


			// comment
			}
			else {
				// prepare sticky regex index
				R_COMMENT.lastIndex = i;
				// execute regex
				let m_comment = R_COMMENT.exec(s);

				// regex was a match
				if(m_comment) {
					// advance index
					i = R_COMMENT.lastIndex;
					if(this.emit_comments) this.emit_comments(m_comment[0]);
					// do not change state
					continue;

			// comment interrupted by eos?
			// match counter: 1
				}
				else {
					// break loop to retry on next chunk if eos
					break;
				}
			} // brace #1
		}

				// ran out of characters
				// update index value
		this.i = i;

		// not yet eos
		if(i < this.n) {
			// expected token was not found
			if(0 === i) {
				// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('post_object');
				}
			}
		}

		// save state before pausing
		this._f_state = this.post_object;

		// store what is unparsed
		this.pre = s.slice(i);

		// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}



	// parse state for base_iri
	base_iri() {
		// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
// prefix id

			// prepare sticky regex index
			R_IRIREF_ESCAPELESS.lastIndex = i;
			// execute regex
			let m_iriref_e_base = R_IRIREF_ESCAPELESS.exec(s);

			// regex was a match
			if(m_iriref_e_base) {
				// advance index
				this.i = R_IRIREF_ESCAPELESS.lastIndex;

				// ref iri
				let s_iri = m_iriref_e_base[1];
				// absolute iri
				if(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
					// set base_url
					this._s_base_url = s_iri;
				}
				// relative iri
				else {
					this._s_base_url = uri.resolve(this._s_base_url, s_iri);
				}		let m_base_iri = R_BASE_IRI.exec(this._s_base_url);
				this._s_base_url = m_base_iri[1];
				this._s_base_url_root = m_base_iri[2] || '';
				this._s_base_url_scheme = m_base_iri[3] || '';
				this._s_base_url_path = m_base_iri[4] || '';


				// emit base event
				this.emit('base', this._s_base_url);

				if(this._b_expecting_full_stop) {
					// change state
					return this.full_stop();
				}

				// goto prefix iri state
				return this.statement();

			// prefix id
			}
			else {
				// prepare sticky regex index
				R_IRIREF.lastIndex = i;
				// execute regex
				let m_iriref_base = R_IRIREF.exec(s);

				// regex was a match
				if(m_iriref_base) {
					// advance index
					this.i = R_IRIREF.lastIndex;

					// ref iri
					let s_iri = m_iriref_base[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);
					// absolute iri
					if(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
						// set base_url
						this._s_base_url = s_iri;
					}
					// relative iri
					else {
						this._s_base_url = uri.resolve(this._s_base_url, s_iri);
					}		let m_base_iri = R_BASE_IRI.exec(this._s_base_url);
					this._s_base_url = m_base_iri[1];
					this._s_base_url_root = m_base_iri[2] || '';
					this._s_base_url_scheme = m_base_iri[3] || '';
					this._s_base_url_path = m_base_iri[4] || '';


					// emit base event
					this.emit('base', this._s_base_url);

					if(this._b_expecting_full_stop) {
						// change state
						return this.full_stop();
					}

					// goto prefix iri state
					return this.statement();

				// for poorly-placed comments
				}
				else {
					// prepare sticky regex index
					R_COMMENT.lastIndex = i;
					// execute regex
					let m_comment = R_COMMENT.exec(s);

					// regex was a match
					if(m_comment) {
						// advance index
						i = R_COMMENT.lastIndex;
						if(this.emit_comments) this.emit_comments(m_comment[0]);
						// do not change state
						continue;

					// match counter: 2
					}
					else {
						// break loop to retry on next chunk if eos
						break;
					}
				} // brace #2
			} // brace #1
		}

				// ran out of characters
				// update index value
		this.i = i;

		// not yet eos
		if(i < this.n) {
			// expected token was not found
			if(0 === i) {
				// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('base_iri');
				}
			}
		}

		// save state before pausing
		this._f_state = this.base_iri;

		// store what is unparsed
		this.pre = s.slice(i);

		// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}



	// parse state for prefix_id
	prefix_id() {
		// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
// prefix id

			// prepare sticky regex index
			R_PREFIX_ID.lastIndex = i;
			// execute regex
			let m_prefix_id = R_PREFIX_ID.exec(s);

			// regex was a match
			if(m_prefix_id) {
				// advance index
				this.i = R_PREFIX_ID.lastIndex;
				// set temp prefix id
				this._s_temp_prefix_id = m_prefix_id[1];

				// goto prefix iri state
				return this.prefix_iri();

			// for poorly-placed comments
			}
			else {
				// prepare sticky regex index
				R_COMMENT.lastIndex = i;
				// execute regex
				let m_comment = R_COMMENT.exec(s);

				// regex was a match
				if(m_comment) {
					// advance index
					i = R_COMMENT.lastIndex;
					if(this.emit_comments) this.emit_comments(m_comment[0]);
					// do not change state
					continue;

				// match counter: 1
				}
				else {
					// break loop to retry on next chunk if eos
					break;
				}
			} // brace #1
		}

				// ran out of characters
				// update index value
		this.i = i;

		// not yet eos
		if(i < this.n) {
			// expected token was not found
			if(0 === i) {
				// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('prefix_id');
				}
			}
		}

		// save state before pausing
		this._f_state = this.prefix_id;

		// store what is unparsed
		this.pre = s.slice(i);

		// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}



	// parse state for prefix_iri
	prefix_iri() {
		// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
			let h_prefixes = this._h_prefixes;
			let s_prefix_id = this._s_temp_prefix_id;
			let p_prefix_iri;

// prefix iri

			// prepare sticky regex index
			R_IRIREF_ESCAPELESS.lastIndex = i;
			// execute regex
			let m_iriref_e_prefix = R_IRIREF_ESCAPELESS.exec(s);

			// regex was a match
			if(m_iriref_e_prefix) {
				// advance index
				this.i = R_IRIREF_ESCAPELESS.lastIndex;

				// ref iri
				let s_iri = m_iriref_e_prefix[1];
				// absolute iri
				if(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
					// set p_prefix_iri
					p_prefix_iri = s_iri;
				}
				// relative iri
				else {
					p_prefix_iri = uri.resolve(this._s_base_url, s_iri);
				}

				let b_relax = this._b_relax;

// existing mapping

				if(s_prefix_id in h_prefixes) {
					// doesn't match existing
					if(p_prefix_iri !== h_prefixes[s_prefix_id]) {
						// emit change event
						if(this.prefix_change) {
							this.prefix_change(s_prefix_id, h_prefixes[s_prefix_id], p_prefix_iri);
						}

						// update prefix
						h_prefixes[s_prefix_id] = p_prefix_iri;
					}
				}
				// first mapping
				else {
					// check namespace, invalid
					if(!b_relax && !RT_PREFIXED_NAME_NAMESPACE_VALID.test(s_prefix_id)) {
						return this.error(`Invalid namespace for prefixed name: "${s_prefix_id}:"`);
					}

					// set prefix
					h_prefixes[s_prefix_id] = p_prefix_iri;
				}

				// check iri, invalid
				if(!b_relax && !RT_NAMED_NODE_VALID.test(p_prefix_iri)) {
					return this.error(`Invalid IRI found in prefix delcaration: "${s_iri}"`);
				}

				// emit prefix event
				this.event('prefix', s_prefix_id, p_prefix_iri);

				if(this._b_expecting_full_stop) {
					// change state
					return this.full_stop();
				}

				// goto statement state
				return this.statement();

			// prefix iri
			}
			else {
				// prepare sticky regex index
				R_IRIREF.lastIndex = i;
				// execute regex
				let m_iriref_prefix = R_IRIREF.exec(s);

				// regex was a match
				if(m_iriref_prefix) {
					// advance index
					this.i = R_IRIREF.lastIndex;

					// ref iri
					let s_iri = m_iriref_prefix[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);
					// absolute iri
					if(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
						// set p_prefix_iri
						p_prefix_iri = s_iri;
					}
					// relative iri
					else {
						p_prefix_iri = uri.resolve(this._s_base_url, s_iri);
					}

					let b_relax = this._b_relax;

// existing mapping

					if(s_prefix_id in h_prefixes) {
						// doesn't match existing
						if(p_prefix_iri !== h_prefixes[s_prefix_id]) {
							// emit change event
							if(this.prefix_change) {
								this.prefix_change(s_prefix_id, h_prefixes[s_prefix_id], p_prefix_iri);
							}

							// update prefix
							h_prefixes[s_prefix_id] = p_prefix_iri;
						}
					}
					// first mapping
					else {
						// check namespace, invalid
						if(!b_relax && !RT_PREFIXED_NAME_NAMESPACE_VALID.test(s_prefix_id)) {
							return this.error(`Invalid namespace for prefixed name: "${s_prefix_id}:"`);
						}

						// set prefix
						h_prefixes[s_prefix_id] = p_prefix_iri;
					}

					// check iri, invalid
					if(!b_relax && !RT_NAMED_NODE_VALID.test(p_prefix_iri)) {
						return this.error(`Invalid IRI found in prefix delcaration: "${s_iri}"`);
					}

					// emit prefix event
					this.event('prefix', s_prefix_id, p_prefix_iri);

					if(this._b_expecting_full_stop) {
						// change state
						return this.full_stop();
					}

					// goto statement state
					return this.statement();

				// for poorly-placed comments
				}
				else {
					// prepare sticky regex index
					R_COMMENT.lastIndex = i;
					// execute regex
					let m_comment = R_COMMENT.exec(s);

					// regex was a match
					if(m_comment) {
						// advance index
						i = R_COMMENT.lastIndex;
						if(this.emit_comments) this.emit_comments(m_comment[0]);
						// do not change state
						continue;

					// match counter: 2
					}
					else {
						// break loop to retry on next chunk if eos
						break;
					}
				} // brace #2
			} // brace #1
		}

				// ran out of characters
				// update index value
		this.i = i;

		// not yet eos
		if(i < this.n) {
			// expected token was not found
			if(0 === i) {
				// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('prefix_iri');
				}
			}
		}

		// save state before pausing
		this._f_state = this.prefix_iri;

		// store what is unparsed
		this.pre = s.slice(i);

		// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}


// in case eos happens twice during prefix / base (extremely unlikely)


	// parse state for full_stop
	full_stop() {
		// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
			// prepare sticky regex index
			R_CHAR_STOP.lastIndex = i;

			if(R_CHAR_STOP.exec(s)) {
				// advance index
				this.i = R_CHAR_STOP.lastIndex;
				// resume statement
				return this.statement();

			// poorly-placed comment
			}
			else {
				// prepare sticky regex index
				R_COMMENT.lastIndex = i;
				// execute regex
				let m_comment = R_COMMENT.exec(s);

				// regex was a match
				if(m_comment) {
					// advance index
					i = R_COMMENT.lastIndex;
					if(this.emit_comments) this.emit_comments(m_comment[0]);
					// try again
					continue;

			// possibly interrupted by eos
			// match counter: 1
				}
				else {
					// break loop to retry on next chunk if eos
					break;
				}
			} // brace #1
		}

				// ran out of characters
				// update index value
		this.i = i;

		// not yet eos
		if(i < this.n) {
			// expected token was not found
			if(0 === i) {
				// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('full_stop');
				}
			}
		}

		// save state before pausing
		this._f_state = this.full_stop;

		// store what is unparsed
		this.pre = s.slice(i);

		// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}



	// parse state for collection_subject
	collection_subject() {
		// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
			// ref char
			let x = s[i];

			// end of collection
			if(')' === x) {
				// consume whitespace (and incidentally reset index)
				R_WS.lastIndex = i+1;
				R_WS.exec(s);
				this.i = R_WS.lastIndex;

				// no items in collection subject
				if(null === this._kt_subject) {
					// prepare subject
					this._kt_subject = this._kt_rdf_nil;

					// state was never pushed to stack, jump to post_subject state
					return this.post_blank_subject();
				}
// otherwise, there must be items in collection

				// commit collection end
				this._kt_object = this._kt_rdf_nil;
				this.data();


				// restore state from stack
				let s_resume_state;
				[this._kt_subject, this._kt_predicate, s_resume_state] = this._a_nested.pop();
				return this[s_resume_state]();
			}



			// otherwise, pre-emptively secure the next blank node label
			let s_pointer_label;

			// very first collection object
			let b_pushed = false;
			if(null === this._kt_subject) {
				// set quasi subject (really for resume state)
				s_pointer_label = this.next_label();
				this._kt_subject = this.anonymous_blank_node(s_pointer_label);
				this._a_nested.push([this._kt_subject, this._kt_predicate, 'pairs']);
				// reset subject for later conditional branch
				this._kt_subject = null;
				b_pushed = true;
			}

// iriref

			// prepare sticky regex index
			R_IRIREF_ESCAPELESS.lastIndex = i;
			// execute regex
			let m_iriref_e_object = R_IRIREF_ESCAPELESS.exec(s);

			// regex was a match
			if(m_iriref_e_object) {
				// advance index
				i = R_IRIREF_ESCAPELESS.lastIndex;

				// ref iri
				let s_iri = m_iriref_e_object[1];
				// absolute iri
				if(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
					// set object
					this._kt_object = this.check_named_node_escapeless(s_iri);
				}
				// relative iri
				else {
					this._kt_object = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));
				}

			// prefixed name
			}
			else {
				// try match
				let aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);
				// stack bail out
				if(!aw_valid_this_match_prefixed_name_escapeless) return true;
				let [m_prefixed_named_e_object, im_prefixed_named_e_object] = aw_valid_this_match_prefixed_name_escapeless;
				if(m_prefixed_named_e_object) {
					// advance index
					i = im_prefixed_named_e_object;
					// check valid prefix
					let s_prefix_id = m_prefixed_named_e_object[1] || '';
					// invalid prefix
					if(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix "${s_prefix_id}"`);


					// commit object iri from resolve prefixed name
					this._kt_object = this.prefixed_name(s_prefix_id, m_prefixed_named_e_object[2]);

				// string literal
				}
				else 	if('"' === x || '\'' === x) {
					// first item in list
					if(null === this._kt_subject) {
						s_pointer_label = this.next_label();
						this._kt_subject = this.anonymous_blank_node(s_pointer_label);
						this._kt_predicate = this._kt_rdf_first;
					}
					// not first item in list
					else {
						// make nest list item
						s_pointer_label = this.next_label();
						let kt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);
						this.data();


						// setup for object literal
						this._kt_subject = kt_blank_node;
						this._kt_predicate = this._kt_rdf_first;
					}

					// how to resume collection subject state after object literal
					this.after_end_of_statement = function() {
						this._kt_predicate = this._kt_rdf_rest;
						this.after_end_of_statement = this.post_object;
						return this.collection_subject();
					};
					return this.string_literal();

				// numeric literal
				}
				else {
					// prepare sticky regex index
					R_NUMERIC_LITERAL.lastIndex = i;
					// execute regex
					let m_numeric_literal = R_NUMERIC_LITERAL.exec(s);

					// regex was a match
					if(m_numeric_literal) {
						// advance index
						i = R_NUMERIC_LITERAL.lastIndex;
						// it has exponent term, xsd:double
						if(m_numeric_literal[4]) {
							this._kt_object = this._dc_factory.double(m_numeric_literal[1]);
						}
						// contains decimal point, xsd:decimal
						else if(m_numeric_literal[2] || m_numeric_literal[3]) {
							this._kt_object = this._dc_factory.decimal(m_numeric_literal[1]);
						}
						// otherwise, it is an integer
						else {
							this._kt_object = this._dc_factory.integer(m_numeric_literal[1]);
						}


					// boolean literal
					}
					else {
						// prepare sticky regex index
						R_BOOLEAN_LITERAL.lastIndex = i;
						// execute regex
						let m_boolean_literal = R_BOOLEAN_LITERAL.exec(s);

						// regex was a match
						if(m_boolean_literal) {
							// advance index
							i = R_BOOLEAN_LITERAL.lastIndex;
							// make literal
							this._kt_object = this._dc_factory.boolean(!!m_boolean_literal[1]);

						// blank node property list
						}
						else 	if('[' === x) {
				// advance index to next token
				// consume whitespace (and incidentally reset index)
							R_WS.lastIndex = i+1;
							R_WS.exec(s);
							this.i = R_WS.lastIndex;

							// this blank node is just the next item in the list
							s_pointer_label = this.next_label();
							let kt_blank_node;
							if(null !== this._kt_subject) {
								kt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);
								this.data();
							}

							// subject needs to be set
							this._kt_subject = kt_blank_node || this.anonymous_blank_node(s_pointer_label);
							this._kt_predicate = this._kt_rdf_first;
							let s_label = this.next_label();
							kt_blank_node = this._kt_object = this.anonymous_blank_node(s_label);
							this.data();


							// when resume
							this._kt_predicate = this._kt_rdf_rest;

							// push state
							this._a_nested.push([this._kt_subject, this._kt_predicate, 'collection_subject']);

							// prepare next triple
							this._kt_subject = kt_blank_node;

							// goto parsing pairs state
							return this.pairs();

						// new collection
						}
						else 	if('(' === x) {
							// consume whitespace (and incidentally reset index)
							R_WS.lastIndex = i+1;
							R_WS.exec(s);
							i = R_WS.lastIndex;

							// empty collection
							if(')' === s[i]) {
								this.i = i;
								this._kt_subject = this._a_nested[this._a_nested.length-1][0];
								this._kt_predicate = this._kt_rdf_first;
								this._a_nested.push([
									this._kt_subject,
									this._kt_rdf_rest,
									'collection_subject',
								]);
								return this.collection_object();
							}



							// commit list item pointer
							s_pointer_label = this.next_label();
							let kt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);
							this.data();


							// add this list as an item to the outer list
							this._kt_subject = kt_blank_node;
							this._kt_predicate = this._kt_rdf_rest;
							this._a_nested.push([this._kt_subject, this._kt_predicate, 'collection_object']);

							// prepare next triple
							this._kt_predicate = this._kt_rdf_first;



							// flowing
							continue;

						// labeled blank node
						}
						else {
							// prepare sticky regex index
							R_BLANK_NODE_LABEL.lastIndex = i;
							// execute regex
							let m_blank_node_label_object = R_BLANK_NODE_LABEL.exec(s);

							// regex was a match
							if(m_blank_node_label_object) {
								// advance index
								i = R_BLANK_NODE_LABEL.lastIndex;
								// ref blank node label
								let s_label = m_blank_node_label_object[1];

								// make object
								this._kt_object = this.blank_node(s_label);

							// iriref
							}
							else {
								// prepare sticky regex index
								R_IRIREF.lastIndex = i;
								// execute regex
								let m_iriref_object = R_IRIREF.exec(s);

								// regex was a match
								if(m_iriref_object) {
									// advance index
									i = R_IRIREF.lastIndex;

									// ref iri
									let s_iri = m_iriref_object[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);
									// absolute iri
									if(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
										// set object
										this._kt_object = this.check_named_node(s_iri);
									}
									// relative iri
									else {
										this._kt_object = this.check_named_node(uri.resolve(this._s_base_url, s_iri));
									}

								// prefixed name
								}
								else {
									// try match
									let aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);
									// stack bail out
									if(!aw_valid_this_match_prefixed_name) return true;
									let [m_prefixed_named_object, im_prefixed_named_object] = aw_valid_this_match_prefixed_name;
									if(m_prefixed_named_object) {
										// advance index
										i = im_prefixed_named_object;
										// check valid prefix
										let s_prefix_id = m_prefixed_named_object[1] || '';
										// invalid prefix
										if(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix "${s_prefix_id}"`);


										// escape local escapes
										let s_suffix = m_prefixed_named_object[2]
											.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)
											.replace(R_PN_LOCAL_ESCAPES, '$1');

										// commit object iri from resolve prefixed name
										this._kt_object = this.prefixed_name(s_prefix_id, s_suffix);
									}
									else {
										// prepare sticky regex index
										R_COMMENT.lastIndex = i;
										// execute regex
										let m_comment = R_COMMENT.exec(s);

										// regex was a match
										if(m_comment) {
											// advance index
											i = R_COMMENT.lastIndex;
											if(this.emit_comments) this.emit_comments(m_comment[0]);
											continue;

			// not iriref, not prefixed name, not string literal, not numeric literal, not boolean literal, not blank node property list, not collection
			// match counter: 7
										}
										else {
											// ran out of characters after pushing state, pop it
											if(b_pushed) this._a_nested.pop();

											// break loop to retry on next chunk if eos
											break;
										}
									} // brace #7
								} // brace #6
							} // brace #5
						} // brace #4
					} // brace #3
				} // brace #2
			} // brace #1


			let kt_blank_node_outer;
			if(!s_pointer_label) s_pointer_label = this.next_label();

			// not the very first item of collection subject
			if(this._kt_subject !== null) {
				// ref object
				let w_object = this._kt_object;

				// create blanknode to embed list
				kt_blank_node_outer = this._kt_object = this.anonymous_blank_node(s_pointer_label);

				// emit statement that functions as collection's head "pointer"
				this.data();


				// swap back object
				this._kt_object = w_object;
			}

			// emit statement that is item
			this._kt_subject = kt_blank_node_outer || this.anonymous_blank_node(s_pointer_label);
			this._kt_predicate = this._kt_rdf_first;
			this.data();


			// prepare next predicate
			this._kt_predicate = this._kt_rdf_rest;
		}

				// ran out of characters
				// update index value
		this.i = i;

		// not yet eos
		if(i < this.n) {
			// expected token was not found
			if(0 === i) {
				// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('collection_subject');
				}
			}
		}

		// save state before pausing
		this._f_state = this.collection_subject;

		// store what is unparsed
		this.pre = s.slice(i);

		// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}



	// parse state for collection_object
	collection_object() {
		// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
			// ref char
			let x = s[i];

			// end of collection
			if(')' === x) {
				// consume whitespace (and incidentally reset index)
				R_WS.lastIndex = i+1;
				R_WS.exec(s);
				this.i = R_WS.lastIndex;

				// make & emit collection's tail "pointer"
				this._kt_object = this._kt_rdf_nil;
				this.data();


				// restore previous state
				let s_resume_state;
				[this._kt_subject, this._kt_predicate, s_resume_state] = this._a_nested.pop();
				return this[s_resume_state]();
			}



			// otherwise, pre-emptively secure the next blank node label
			let s_pointer_label;

// iriref

			// prepare sticky regex index
			R_IRIREF_ESCAPELESS.lastIndex = i;
			// execute regex
			let m_iriref_e_object = R_IRIREF_ESCAPELESS.exec(s);

			// regex was a match
			if(m_iriref_e_object) {
				// advance index
				i = R_IRIREF_ESCAPELESS.lastIndex;
// commit object iri as is

				// ref iri
				let s_iri = m_iriref_e_object[1];
				// absolute iri
				if(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
					// set object
					this._kt_object = this.check_named_node_escapeless(s_iri);
				}
				// relative iri
				else {
					this._kt_object = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));
				}

			// prefixed name
			}
			else {
				// try match
				let aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);
				// stack bail out
				if(!aw_valid_this_match_prefixed_name_escapeless) return true;
				let [m_prefixed_named_e_object, im_prefixed_named_e_object] = aw_valid_this_match_prefixed_name_escapeless;
				if(m_prefixed_named_e_object) {
					// advance index
					i = im_prefixed_named_e_object;
					// check valid prefix
					let s_prefix_id = m_prefixed_named_e_object[1] || '';
					// invalid prefix
					if(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix "${s_prefix_id}"`);


					// commit object iri from resolve prefixed name
					this._kt_object = this.prefixed_name(s_prefix_id, m_prefixed_named_e_object[2]);

				// string literal
				}
				else 	if('"' === x || '\'' === x) {
					// update index before changing states
					this.i = i;

					// create blanknode to embed list
					let kt_blank_node = this._kt_object = this.anonymous_blank_node(this.next_label());

					// emit statement that functions as collection's head "pointer"
					this.data();


					// prepare statement that is item
					this._kt_subject = kt_blank_node;
					this._kt_predicate = this._kt_rdf_first;

					this.after_end_of_statement = function() {
						this._kt_predicate = this._kt_rdf_rest;
						this.after_end_of_statement = this.post_object;
						return this.collection_object();
					};
					return this.string_literal();

				// numeric literal
				}
				else {
					// prepare sticky regex index
					R_NUMERIC_LITERAL.lastIndex = i;
					// execute regex
					let m_numeric_literal = R_NUMERIC_LITERAL.exec(s);

					// regex was a match
					if(m_numeric_literal) {
						// advance index
						i = R_NUMERIC_LITERAL.lastIndex;
						// it has exponent term, xsd:double
						if(m_numeric_literal[4]) {
							this._kt_object = this._dc_factory.double(m_numeric_literal[1]);
						}
						// contains decimal point, xsd:decimal
						else if(m_numeric_literal[2] || m_numeric_literal[3]) {
							this._kt_object = this._dc_factory.decimal(m_numeric_literal[1]);
						}
						// otherwise, it is an integer
						else {
							this._kt_object = this._dc_factory.integer(m_numeric_literal[1]);
						}


					// boolean literal
					}
					else {
						// prepare sticky regex index
						R_BOOLEAN_LITERAL.lastIndex = i;
						// execute regex
						let m_boolean_literal = R_BOOLEAN_LITERAL.exec(s);

						// regex was a match
						if(m_boolean_literal) {
							// advance index
							i = R_BOOLEAN_LITERAL.lastIndex;
							// make literal
							this._kt_object = this._dc_factory.booelan(!!m_boolean_literal[1]);

						// blank node property list
						}
						else 	if('[' === x) {
				// advance index to next token
				// consume whitespace (and incidentally reset index)
							R_WS.lastIndex = i+1;
							R_WS.exec(s);
							this.i = R_WS.lastIndex;

							// commit head of list pointer
							let kt_blank_node = this._kt_object = this.anonymous_blank_node(this.next_label());
							this.data();


							// setup state to resume and push
							this._kt_subject = kt_blank_node;
							this._kt_predicate = this._kt_rdf_rest;
							this._a_nested.push([this._kt_subject, this._kt_predicate, 'collection_object']);

							// enter blank node
							this._kt_predicate = this._kt_rdf_first;
							kt_blank_node = this._kt_object = this.anonymous_blank_node(this.next_label());
							this.data();


							// prepare next triple
							this._kt_subject = kt_blank_node;
							this._kt_predicate = this._kt_rdf_first;

							// goto parsing pairs state
							return this.pairs();

						// new collection
						}
						else 	if('(' === x) {
							// consume whitespace (and incidentally reset index)
							R_WS.lastIndex = i+1;
							R_WS.exec(s);
							i = R_WS.lastIndex;

							// commit list item pointer
							s_pointer_label = this.next_label();
							let kt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);
							if(null === this._kt_subject) {
								let a_recent = this._a_nested[this._a_nested.length-1];
								this._kt_subject = a_recent[0];
								this._kt_predicate = a_recent[1];
							}
							this.data();


							// add this list as an item to the outer list
							this._kt_subject = kt_blank_node;
							this._kt_predicate = this._kt_rdf_rest;
							this._a_nested.push([this._kt_subject, this._kt_predicate, 'collection_object']);

							// prepare next triple
							this._kt_predicate = this._kt_rdf_first;

							// flowing
							continue;

						// labeled blank node
						}
						else {
							// prepare sticky regex index
							R_BLANK_NODE_LABEL.lastIndex = i;
							// execute regex
							let m_blank_node_label_object = R_BLANK_NODE_LABEL.exec(s);

							// regex was a match
							if(m_blank_node_label_object) {
								// advance index
								i = R_BLANK_NODE_LABEL.lastIndex;
								// ref blank node label
								let s_label = m_blank_node_label_object[1];

								// make collection pointer label first
								s_pointer_label = this.next_label();

								// make object
								this._kt_object = this.blank_node(s_label);

							// iriref
							}
							else {
								// prepare sticky regex index
								R_IRIREF.lastIndex = i;
								// execute regex
								let m_iriref_object = R_IRIREF.exec(s);

								// regex was a match
								if(m_iriref_object) {
									// advance index
									i = R_IRIREF.lastIndex;
// commit object iri as is

									// ref iri
									let s_iri = m_iriref_object[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);
									// absolute iri
									if(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
										// set object
										this._kt_object = this.check_named_node(s_iri);
									}
									// relative iri
									else {
										this._kt_object = this.check_named_node(uri.resolve(this._s_base_url, s_iri));
									}

								// prefixed name
								}
								else {
									// try match
									let aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);
									// stack bail out
									if(!aw_valid_this_match_prefixed_name) return true;
									let [m_prefixed_named_object, im_prefixed_named_object] = aw_valid_this_match_prefixed_name;
									if(m_prefixed_named_object) {
										// advance index
										i = im_prefixed_named_object;
										// check valid prefix
										let s_prefix_id = m_prefixed_named_object[1] || '';
										// invalid prefix
										if(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix "${s_prefix_id}"`);


										// escape local escapes
										let s_suffix = m_prefixed_named_object[2]
											.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)
											.replace(R_PN_LOCAL_ESCAPES, '$1');

										// commit object iri from resolve prefixed name
										this._kt_object = this.prefixed_name(s_prefix_id, s_suffix);
									}
									else {
										// prepare sticky regex index
										R_COMMENT.lastIndex = i;
										// execute regex
										let m_comment = R_COMMENT.exec(s);

										// regex was a match
										if(m_comment) {
											// advance index
											i = R_COMMENT.lastIndex;
											if(this.emit_comments) this.emit_comments(m_comment[0]);
											continue;

			// not iriref, not prefixed name, not string literal, not numeric literal, not boolean literal, not blank node property list, not collection
			// match counter: 7
										}
										else {
											// break loop to retry on next chunk if eos
											break;
										}
									} // brace #7
								} // brace #6
							} // brace #5
						} // brace #4
					} // brace #3
				} // brace #2
			} // brace #1



			// ref object
			let w_object = this._kt_object;

			// create blanknode to embed list
			if(!s_pointer_label) s_pointer_label = this.next_label();
			let kt_blank_node_outer = this._kt_object = this.anonymous_blank_node(s_pointer_label);

			// emit statement that functions as collection's head "pointer"
			this.data();


			// emit statement that is item
			this._kt_subject = kt_blank_node_outer;
			this._kt_predicate = this._kt_rdf_first;
			this._kt_object = w_object;
			this.data();


			// prepare next predicate
			this._kt_predicate = this._kt_rdf_rest;
		}

				// ran out of characters
				// update index value
		this.i = i;

		// not yet eos
		if(i < this.n) {
			// expected token was not found
			if(0 === i) {
				// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('collection_object');
				}
			}
		}

		// save state before pausing
		this._f_state = this.collection_object;

		// store what is unparsed
		this.pre = s.slice(i);

		// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}


	destroy(e_destroy) {
		this.post_blank_subject = () => {};

		this.statement = () => {};

		this.pairs = () => {};

		this.object_list = () => {};

		this.string_literal_short_double = () => {};

		this.string_literal_short_single = () => {};

		this.string_literal_long_double = () => {};

		this.string_literal_long_single = () => {};

		this.string_literal = () => {};

		this.datatype_or_langtag = () => {};

		this.datatype = () => {};

		this.post_object = () => {};

		this.base_iri = () => {};

		this.prefix_id = () => {};

		this.prefix_iri = () => {};

		this.full_stop = () => {};

		this.collection_subject = () => {};

		this.collection_object = () => {};


		this.eof = () => {
			this.s = null;
		};

		this._b_destroyed = true;

		// propagate input destroy
		if(!e_destroy && this._ds_input) {
			this._ds_input.destroy(e_destroy);
		}

		this.transform.demolish(e_destroy);
	}
}

module.exports = function(...a_args) {
	let g_config = {};

	// at least one argument
	if(a_args.length) {
		let z_arg_0 = a_args[0];

		// string
		if('string' === typeof z_arg_0) {
			g_config.input = {string:z_arg_0};
		}
		// null
		else if(null === z_arg_0) {
			g_config.input = null;
		}
		// node stream
		else if('function' === typeof z_arg_0.setEncoding) {
			g_config.input = {stream:z_arg_0};
		}
		// whatwg stream
		else if('function' === typeof z_arg_0.pipeTo) {
			throw new TypeError(`Sorry, WHATWG streams are currently not supported :(`);
		// g_config.input = {stream:z_arg_0};
		}
		// config struct
		else if(z_arg_0 && 'object' === typeof z_arg_0 && '[object Object]' === Object.prototype.toString.call(z_arg_0)) {
			g_config = z_arg_0;

			// more args; invalid
			if(a_args.length > 1) {
				throw new TypeError(`unexpected argument(s) after config struct: ${a_args.slice(1)}`);
			}
		}
		// unknown
		else {
			throw new TypeError(`unexpected input type: ${z_arg_0}`);
		}

		// more args
		if(a_args.length > 1) {
			// copy onto struct
			Object.assign(g_config, a_args[1]);

			// more args
			if(a_args.length > 2) {
				throw new TypeError(`unexpected argument(s) after input and config struct: ${a_args.slice(2)}`);
			}
		}
	}

	// create reader, return transform stream
	return (new Reader(g_config)).transform;
};
